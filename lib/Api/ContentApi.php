<?php
/**
 * ContentApi
 * PHP version 7.4
 *
 * @category Class
 * @package  OpenAPI\Client
 * @author   OpenAPI Generator team
 * @link     https://openapi-generator.tech
 */

/**
 * Rapid
 *
 * EPS Rapid V3
 *
 * The version of the OpenAPI document: v3
 * Generated by: https://openapi-generator.tech
 * OpenAPI Generator version: 7.0.1
 */

/**
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

namespace OpenAPI\Client\Api;

use GuzzleHttp\Client;
use GuzzleHttp\ClientInterface;
use GuzzleHttp\Exception\ConnectException;
use GuzzleHttp\Exception\RequestException;
use GuzzleHttp\Psr7\MultipartStream;
use GuzzleHttp\Psr7\Request;
use GuzzleHttp\RequestOptions;
use OpenAPI\Client\ApiException;
use OpenAPI\Client\Configuration;
use OpenAPI\Client\HeaderSelector;
use OpenAPI\Client\ObjectSerializer;

/**
 * ContentApi Class Doc Comment
 *
 * @category Class
 * @package  OpenAPI\Client
 * @author   OpenAPI Generator team
 * @link     https://openapi-generator.tech
 */
class ContentApi
{
    /**
     * @var ClientInterface
     */
    protected $client;

    /**
     * @var Configuration
     */
    protected $config;

    /**
     * @var HeaderSelector
     */
    protected $headerSelector;

    /**
     * @var int Host index
     */
    protected $hostIndex;

    /** @var string[] $contentTypes **/
    public const contentTypes = [
        'getChainReference' => [
            'application/json',
        ],
        'getInactiveProperties' => [
            'application/json',
        ],
        'getPropertyCatalogFile' => [
            'application/json',
        ],
        'getPropertyContent' => [
            'application/json',
        ],
        'getPropertyContentFile' => [
            'application/json',
        ],
        'getPropertyGuestReviews' => [
            'application/json',
        ],
    ];

/**
     * @param ClientInterface $client
     * @param Configuration   $config
     * @param HeaderSelector  $selector
     * @param int             $hostIndex (Optional) host index to select the list of hosts if defined in the OpenAPI spec
     */
    public function __construct(
        ClientInterface $client = null,
        Configuration $config = null,
        HeaderSelector $selector = null,
        $hostIndex = 0
    ) {
        $this->client = $client ?: new Client();
        $this->config = $config ?: new Configuration();
        $this->headerSelector = $selector ?: new HeaderSelector();
        $this->hostIndex = $hostIndex;
    }

    /**
     * Set the host index
     *
     * @param int $hostIndex Host index (required)
     */
    public function setHostIndex($hostIndex): void
    {
        $this->hostIndex = $hostIndex;
    }

    /**
     * Get the host index
     *
     * @return int Host index
     */
    public function getHostIndex()
    {
        return $this->hostIndex;
    }

    /**
     * @return Configuration
     */
    public function getConfig()
    {
        return $this->config;
    }

    /**
     * Operation getChainReference
     *
     * Chain Reference
     *
     * @param  string $accept Specifies the response format that the client would like to receive back. This must be &#x60;application/json&#x60;. (required)
     * @param  string $accept_encoding Specifies the response encoding that the client would like to receive back. This must be &#x60;gzip&#x60;. (required)
     * @param  string $user_agent The &#x60;User-Agent&#x60; header string from the customer&#39;s request, as captured by your integration. If you are building an application then the &#x60;User-Agent&#x60; value should be &#x60;{app name}/{app version}&#x60;. (required)
     * @param  string $customer_session_id Insert your own unique value for each user session, beginning with the first API call. Continue to pass the same value for each subsequent API call during the user&#39;s session, using a new value for every new customer session.&lt;br&gt; Including this value greatly eases EPS&#39;s internal debugging process for issues with partner requests, as it explicitly links together request paths for individual user&#39;s session. (optional)
     * @param  string $billing_terms This parameter is to specify the terms of how a resulting booking should be billed. If this field is needed, the value for this will be provided to you separately. (optional)
     * @param  string $partner_point_of_sale This parameter is to specify what point of sale is being used to shop and book. If this field is needed, the value for this will be provided to you separately. (optional)
     * @param  string $payment_terms This parameter is to specify what terms should be used when being paid for a resulting booking. If this field is needed, the value for this will be provided to you separately. (optional)
     * @param  string $platform_name This parameter is to specify what platform is being used to shop and book. If this field is needed, the value for this will be provided to you separately. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getChainReference'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array<string,\OpenAPI\Client\Model\Chain>|\OpenAPI\Client\Model\Error|\OpenAPI\Client\Model\Error|\OpenAPI\Client\Model\Error|\OpenAPI\Client\Model\Error|\OpenAPI\Client\Model\Error|\OpenAPI\Client\Model\Error
     */
    public function getChainReference($accept, $accept_encoding, $user_agent, $customer_session_id = null, $billing_terms = null, $partner_point_of_sale = null, $payment_terms = null, $platform_name = null, string $contentType = self::contentTypes['getChainReference'][0])
    {
        list($response) = $this->getChainReferenceWithHttpInfo($accept, $accept_encoding, $user_agent, $customer_session_id, $billing_terms, $partner_point_of_sale, $payment_terms, $platform_name, $contentType);
        return $response;
    }

    /**
     * Operation getChainReferenceWithHttpInfo
     *
     * Chain Reference
     *
     * @param  string $accept Specifies the response format that the client would like to receive back. This must be &#x60;application/json&#x60;. (required)
     * @param  string $accept_encoding Specifies the response encoding that the client would like to receive back. This must be &#x60;gzip&#x60;. (required)
     * @param  string $user_agent The &#x60;User-Agent&#x60; header string from the customer&#39;s request, as captured by your integration. If you are building an application then the &#x60;User-Agent&#x60; value should be &#x60;{app name}/{app version}&#x60;. (required)
     * @param  string $customer_session_id Insert your own unique value for each user session, beginning with the first API call. Continue to pass the same value for each subsequent API call during the user&#39;s session, using a new value for every new customer session.&lt;br&gt; Including this value greatly eases EPS&#39;s internal debugging process for issues with partner requests, as it explicitly links together request paths for individual user&#39;s session. (optional)
     * @param  string $billing_terms This parameter is to specify the terms of how a resulting booking should be billed. If this field is needed, the value for this will be provided to you separately. (optional)
     * @param  string $partner_point_of_sale This parameter is to specify what point of sale is being used to shop and book. If this field is needed, the value for this will be provided to you separately. (optional)
     * @param  string $payment_terms This parameter is to specify what terms should be used when being paid for a resulting booking. If this field is needed, the value for this will be provided to you separately. (optional)
     * @param  string $platform_name This parameter is to specify what platform is being used to shop and book. If this field is needed, the value for this will be provided to you separately. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getChainReference'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of array<string,\OpenAPI\Client\Model\Chain>|\OpenAPI\Client\Model\Error|\OpenAPI\Client\Model\Error|\OpenAPI\Client\Model\Error|\OpenAPI\Client\Model\Error|\OpenAPI\Client\Model\Error|\OpenAPI\Client\Model\Error, HTTP status code, HTTP response headers (array of strings)
     */
    public function getChainReferenceWithHttpInfo($accept, $accept_encoding, $user_agent, $customer_session_id = null, $billing_terms = null, $partner_point_of_sale = null, $payment_terms = null, $platform_name = null, string $contentType = self::contentTypes['getChainReference'][0])
    {
        $request = $this->getChainReferenceRequest($accept, $accept_encoding, $user_agent, $customer_session_id, $billing_terms, $partner_point_of_sale, $payment_terms, $platform_name, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('array<string,\OpenAPI\Client\Model\Chain>' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('array<string,\OpenAPI\Client\Model\Chain>' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, 'array<string,\OpenAPI\Client\Model\Chain>', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 401:
                    if ('\OpenAPI\Client\Model\Error' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\Error' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\Error', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 403:
                    if ('\OpenAPI\Client\Model\Error' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\Error' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\Error', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 426:
                    if ('\OpenAPI\Client\Model\Error' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\Error' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\Error', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 429:
                    if ('\OpenAPI\Client\Model\Error' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\Error' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\Error', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 500:
                    if ('\OpenAPI\Client\Model\Error' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\Error' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\Error', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 503:
                    if ('\OpenAPI\Client\Model\Error' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\Error' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\Error', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = 'array<string,\OpenAPI\Client\Model\Chain>';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'array<string,\OpenAPI\Client\Model\Chain>',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 401:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\Error',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 403:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\Error',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 426:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\Error',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 429:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\Error',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 500:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\Error',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 503:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\Error',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getChainReferenceAsync
     *
     * Chain Reference
     *
     * @param  string $accept Specifies the response format that the client would like to receive back. This must be &#x60;application/json&#x60;. (required)
     * @param  string $accept_encoding Specifies the response encoding that the client would like to receive back. This must be &#x60;gzip&#x60;. (required)
     * @param  string $user_agent The &#x60;User-Agent&#x60; header string from the customer&#39;s request, as captured by your integration. If you are building an application then the &#x60;User-Agent&#x60; value should be &#x60;{app name}/{app version}&#x60;. (required)
     * @param  string $customer_session_id Insert your own unique value for each user session, beginning with the first API call. Continue to pass the same value for each subsequent API call during the user&#39;s session, using a new value for every new customer session.&lt;br&gt; Including this value greatly eases EPS&#39;s internal debugging process for issues with partner requests, as it explicitly links together request paths for individual user&#39;s session. (optional)
     * @param  string $billing_terms This parameter is to specify the terms of how a resulting booking should be billed. If this field is needed, the value for this will be provided to you separately. (optional)
     * @param  string $partner_point_of_sale This parameter is to specify what point of sale is being used to shop and book. If this field is needed, the value for this will be provided to you separately. (optional)
     * @param  string $payment_terms This parameter is to specify what terms should be used when being paid for a resulting booking. If this field is needed, the value for this will be provided to you separately. (optional)
     * @param  string $platform_name This parameter is to specify what platform is being used to shop and book. If this field is needed, the value for this will be provided to you separately. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getChainReference'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getChainReferenceAsync($accept, $accept_encoding, $user_agent, $customer_session_id = null, $billing_terms = null, $partner_point_of_sale = null, $payment_terms = null, $platform_name = null, string $contentType = self::contentTypes['getChainReference'][0])
    {
        return $this->getChainReferenceAsyncWithHttpInfo($accept, $accept_encoding, $user_agent, $customer_session_id, $billing_terms, $partner_point_of_sale, $payment_terms, $platform_name, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getChainReferenceAsyncWithHttpInfo
     *
     * Chain Reference
     *
     * @param  string $accept Specifies the response format that the client would like to receive back. This must be &#x60;application/json&#x60;. (required)
     * @param  string $accept_encoding Specifies the response encoding that the client would like to receive back. This must be &#x60;gzip&#x60;. (required)
     * @param  string $user_agent The &#x60;User-Agent&#x60; header string from the customer&#39;s request, as captured by your integration. If you are building an application then the &#x60;User-Agent&#x60; value should be &#x60;{app name}/{app version}&#x60;. (required)
     * @param  string $customer_session_id Insert your own unique value for each user session, beginning with the first API call. Continue to pass the same value for each subsequent API call during the user&#39;s session, using a new value for every new customer session.&lt;br&gt; Including this value greatly eases EPS&#39;s internal debugging process for issues with partner requests, as it explicitly links together request paths for individual user&#39;s session. (optional)
     * @param  string $billing_terms This parameter is to specify the terms of how a resulting booking should be billed. If this field is needed, the value for this will be provided to you separately. (optional)
     * @param  string $partner_point_of_sale This parameter is to specify what point of sale is being used to shop and book. If this field is needed, the value for this will be provided to you separately. (optional)
     * @param  string $payment_terms This parameter is to specify what terms should be used when being paid for a resulting booking. If this field is needed, the value for this will be provided to you separately. (optional)
     * @param  string $platform_name This parameter is to specify what platform is being used to shop and book. If this field is needed, the value for this will be provided to you separately. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getChainReference'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getChainReferenceAsyncWithHttpInfo($accept, $accept_encoding, $user_agent, $customer_session_id = null, $billing_terms = null, $partner_point_of_sale = null, $payment_terms = null, $platform_name = null, string $contentType = self::contentTypes['getChainReference'][0])
    {
        $returnType = 'array<string,\OpenAPI\Client\Model\Chain>';
        $request = $this->getChainReferenceRequest($accept, $accept_encoding, $user_agent, $customer_session_id, $billing_terms, $partner_point_of_sale, $payment_terms, $platform_name, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getChainReference'
     *
     * @param  string $accept Specifies the response format that the client would like to receive back. This must be &#x60;application/json&#x60;. (required)
     * @param  string $accept_encoding Specifies the response encoding that the client would like to receive back. This must be &#x60;gzip&#x60;. (required)
     * @param  string $user_agent The &#x60;User-Agent&#x60; header string from the customer&#39;s request, as captured by your integration. If you are building an application then the &#x60;User-Agent&#x60; value should be &#x60;{app name}/{app version}&#x60;. (required)
     * @param  string $customer_session_id Insert your own unique value for each user session, beginning with the first API call. Continue to pass the same value for each subsequent API call during the user&#39;s session, using a new value for every new customer session.&lt;br&gt; Including this value greatly eases EPS&#39;s internal debugging process for issues with partner requests, as it explicitly links together request paths for individual user&#39;s session. (optional)
     * @param  string $billing_terms This parameter is to specify the terms of how a resulting booking should be billed. If this field is needed, the value for this will be provided to you separately. (optional)
     * @param  string $partner_point_of_sale This parameter is to specify what point of sale is being used to shop and book. If this field is needed, the value for this will be provided to you separately. (optional)
     * @param  string $payment_terms This parameter is to specify what terms should be used when being paid for a resulting booking. If this field is needed, the value for this will be provided to you separately. (optional)
     * @param  string $platform_name This parameter is to specify what platform is being used to shop and book. If this field is needed, the value for this will be provided to you separately. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getChainReference'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function getChainReferenceRequest($accept, $accept_encoding, $user_agent, $customer_session_id = null, $billing_terms = null, $partner_point_of_sale = null, $payment_terms = null, $platform_name = null, string $contentType = self::contentTypes['getChainReference'][0])
    {

        // verify the required parameter 'accept' is set
        if ($accept === null || (is_array($accept) && count($accept) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $accept when calling getChainReference'
            );
        }

        // verify the required parameter 'accept_encoding' is set
        if ($accept_encoding === null || (is_array($accept_encoding) && count($accept_encoding) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $accept_encoding when calling getChainReference'
            );
        }

        // verify the required parameter 'user_agent' is set
        if ($user_agent === null || (is_array($user_agent) && count($user_agent) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $user_agent when calling getChainReference'
            );
        }







        $resourcePath = '/chains';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $billing_terms,
            'billing_terms', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $partner_point_of_sale,
            'partner_point_of_sale', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $payment_terms,
            'payment_terms', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $platform_name,
            'platform_name', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);

        // header params
        if ($accept !== null) {
            $headerParams['Accept'] = ObjectSerializer::toHeaderValue($accept);
        }
        // header params
        if ($accept_encoding !== null) {
            $headerParams['Accept-Encoding'] = ObjectSerializer::toHeaderValue($accept_encoding);
        }
        // header params
        if ($customer_session_id !== null) {
            $headerParams['Customer-Session-Id'] = ObjectSerializer::toHeaderValue($customer_session_id);
        }
        // header params
        if ($user_agent !== null) {
            $headerParams['User-Agent'] = ObjectSerializer::toHeaderValue($user_agent);
        }



        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getInactiveProperties
     *
     * Inactive Properties
     *
     * @param  string $accept Specifies the response format that the client would like to receive back. This must be &#x60;application/json&#x60;. (required)
     * @param  string $accept_encoding Specifies the response encoding that the client would like to receive back. This must be &#x60;gzip&#x60;. (required)
     * @param  string $user_agent The &#x60;User-Agent&#x60; header string from the customer&#39;s request, as captured by your integration. If you are  building an application then the &#x60;User-Agent&#x60; value should be &#x60;{app name}/{app version}&#x60;. (required)
     * @param  string $customer_session_id Insert your own unique value for each user session, beginning with the first API call. Continue to pass the same value for each subsequent API call during the user&#39;s session, using a new value for every new customer session.&lt;br&gt; Including this value greatly eases EPS&#39;s internal debugging process for issues with partner requests, as it explicitly links together request paths for individual user&#39;s session. (optional)
     * @param  string $since Required on initial call, not accepted on subsequent paging links provided in response header.&lt;br&gt; The earliest date that a property became inactive to include in the results. ISO 8601 format (YYYY-MM-DD) (optional)
     * @param  string $token Only used for requesting additional pages of data. Provided by the &#x60;next&#x60; URL in the &#x60;Link&#x60; response header. (optional)
     * @param  string $billing_terms This parameter is to specify the terms of how a resulting booking should be billed. If this field is needed, the value for this will be provided to you separately. (optional)
     * @param  string $payment_terms This parameter is to specify what terms should be used when being paid for a resulting booking. If this field is needed, the value for this will be provided to you separately. (optional)
     * @param  string $partner_point_of_sale This parameter is to specify what point of sale is being used to shop and book. If this field is needed, the value for this will be provided to you separately. (optional)
     * @param  string $platform_name This parameter is to specify what platform is being used to shop and book. If this field is needed, the value for this will be provided to you separately. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getInactiveProperties'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\PropertyInactive[]|\OpenAPI\Client\Model\Error|\OpenAPI\Client\Model\Error|\OpenAPI\Client\Model\Error|\OpenAPI\Client\Model\Error|\OpenAPI\Client\Model\Error|\OpenAPI\Client\Model\Error|\OpenAPI\Client\Model\Error|\OpenAPI\Client\Model\Error
     */
    public function getInactiveProperties($accept, $accept_encoding, $user_agent, $customer_session_id = null, $since = null, $token = null, $billing_terms = null, $payment_terms = null, $partner_point_of_sale = null, $platform_name = null, string $contentType = self::contentTypes['getInactiveProperties'][0])
    {
        list($response) = $this->getInactivePropertiesWithHttpInfo($accept, $accept_encoding, $user_agent, $customer_session_id, $since, $token, $billing_terms, $payment_terms, $partner_point_of_sale, $platform_name, $contentType);
        return $response;
    }

    /**
     * Operation getInactivePropertiesWithHttpInfo
     *
     * Inactive Properties
     *
     * @param  string $accept Specifies the response format that the client would like to receive back. This must be &#x60;application/json&#x60;. (required)
     * @param  string $accept_encoding Specifies the response encoding that the client would like to receive back. This must be &#x60;gzip&#x60;. (required)
     * @param  string $user_agent The &#x60;User-Agent&#x60; header string from the customer&#39;s request, as captured by your integration. If you are  building an application then the &#x60;User-Agent&#x60; value should be &#x60;{app name}/{app version}&#x60;. (required)
     * @param  string $customer_session_id Insert your own unique value for each user session, beginning with the first API call. Continue to pass the same value for each subsequent API call during the user&#39;s session, using a new value for every new customer session.&lt;br&gt; Including this value greatly eases EPS&#39;s internal debugging process for issues with partner requests, as it explicitly links together request paths for individual user&#39;s session. (optional)
     * @param  string $since Required on initial call, not accepted on subsequent paging links provided in response header.&lt;br&gt; The earliest date that a property became inactive to include in the results. ISO 8601 format (YYYY-MM-DD) (optional)
     * @param  string $token Only used for requesting additional pages of data. Provided by the &#x60;next&#x60; URL in the &#x60;Link&#x60; response header. (optional)
     * @param  string $billing_terms This parameter is to specify the terms of how a resulting booking should be billed. If this field is needed, the value for this will be provided to you separately. (optional)
     * @param  string $payment_terms This parameter is to specify what terms should be used when being paid for a resulting booking. If this field is needed, the value for this will be provided to you separately. (optional)
     * @param  string $partner_point_of_sale This parameter is to specify what point of sale is being used to shop and book. If this field is needed, the value for this will be provided to you separately. (optional)
     * @param  string $platform_name This parameter is to specify what platform is being used to shop and book. If this field is needed, the value for this will be provided to you separately. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getInactiveProperties'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\PropertyInactive[]|\OpenAPI\Client\Model\Error|\OpenAPI\Client\Model\Error|\OpenAPI\Client\Model\Error|\OpenAPI\Client\Model\Error|\OpenAPI\Client\Model\Error|\OpenAPI\Client\Model\Error|\OpenAPI\Client\Model\Error|\OpenAPI\Client\Model\Error, HTTP status code, HTTP response headers (array of strings)
     */
    public function getInactivePropertiesWithHttpInfo($accept, $accept_encoding, $user_agent, $customer_session_id = null, $since = null, $token = null, $billing_terms = null, $payment_terms = null, $partner_point_of_sale = null, $platform_name = null, string $contentType = self::contentTypes['getInactiveProperties'][0])
    {
        $request = $this->getInactivePropertiesRequest($accept, $accept_encoding, $user_agent, $customer_session_id, $since, $token, $billing_terms, $payment_terms, $partner_point_of_sale, $platform_name, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\PropertyInactive[]' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\PropertyInactive[]' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\PropertyInactive[]', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 400:
                    if ('\OpenAPI\Client\Model\Error' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\Error' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\Error', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 401:
                    if ('\OpenAPI\Client\Model\Error' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\Error' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\Error', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 403:
                    if ('\OpenAPI\Client\Model\Error' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\Error' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\Error', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 410:
                    if ('\OpenAPI\Client\Model\Error' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\Error' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\Error', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 426:
                    if ('\OpenAPI\Client\Model\Error' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\Error' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\Error', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 429:
                    if ('\OpenAPI\Client\Model\Error' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\Error' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\Error', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 500:
                    if ('\OpenAPI\Client\Model\Error' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\Error' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\Error', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 503:
                    if ('\OpenAPI\Client\Model\Error' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\Error' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\Error', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\PropertyInactive[]';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\PropertyInactive[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\Error',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 401:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\Error',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 403:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\Error',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 410:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\Error',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 426:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\Error',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 429:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\Error',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 500:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\Error',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 503:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\Error',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getInactivePropertiesAsync
     *
     * Inactive Properties
     *
     * @param  string $accept Specifies the response format that the client would like to receive back. This must be &#x60;application/json&#x60;. (required)
     * @param  string $accept_encoding Specifies the response encoding that the client would like to receive back. This must be &#x60;gzip&#x60;. (required)
     * @param  string $user_agent The &#x60;User-Agent&#x60; header string from the customer&#39;s request, as captured by your integration. If you are  building an application then the &#x60;User-Agent&#x60; value should be &#x60;{app name}/{app version}&#x60;. (required)
     * @param  string $customer_session_id Insert your own unique value for each user session, beginning with the first API call. Continue to pass the same value for each subsequent API call during the user&#39;s session, using a new value for every new customer session.&lt;br&gt; Including this value greatly eases EPS&#39;s internal debugging process for issues with partner requests, as it explicitly links together request paths for individual user&#39;s session. (optional)
     * @param  string $since Required on initial call, not accepted on subsequent paging links provided in response header.&lt;br&gt; The earliest date that a property became inactive to include in the results. ISO 8601 format (YYYY-MM-DD) (optional)
     * @param  string $token Only used for requesting additional pages of data. Provided by the &#x60;next&#x60; URL in the &#x60;Link&#x60; response header. (optional)
     * @param  string $billing_terms This parameter is to specify the terms of how a resulting booking should be billed. If this field is needed, the value for this will be provided to you separately. (optional)
     * @param  string $payment_terms This parameter is to specify what terms should be used when being paid for a resulting booking. If this field is needed, the value for this will be provided to you separately. (optional)
     * @param  string $partner_point_of_sale This parameter is to specify what point of sale is being used to shop and book. If this field is needed, the value for this will be provided to you separately. (optional)
     * @param  string $platform_name This parameter is to specify what platform is being used to shop and book. If this field is needed, the value for this will be provided to you separately. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getInactiveProperties'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getInactivePropertiesAsync($accept, $accept_encoding, $user_agent, $customer_session_id = null, $since = null, $token = null, $billing_terms = null, $payment_terms = null, $partner_point_of_sale = null, $platform_name = null, string $contentType = self::contentTypes['getInactiveProperties'][0])
    {
        return $this->getInactivePropertiesAsyncWithHttpInfo($accept, $accept_encoding, $user_agent, $customer_session_id, $since, $token, $billing_terms, $payment_terms, $partner_point_of_sale, $platform_name, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getInactivePropertiesAsyncWithHttpInfo
     *
     * Inactive Properties
     *
     * @param  string $accept Specifies the response format that the client would like to receive back. This must be &#x60;application/json&#x60;. (required)
     * @param  string $accept_encoding Specifies the response encoding that the client would like to receive back. This must be &#x60;gzip&#x60;. (required)
     * @param  string $user_agent The &#x60;User-Agent&#x60; header string from the customer&#39;s request, as captured by your integration. If you are  building an application then the &#x60;User-Agent&#x60; value should be &#x60;{app name}/{app version}&#x60;. (required)
     * @param  string $customer_session_id Insert your own unique value for each user session, beginning with the first API call. Continue to pass the same value for each subsequent API call during the user&#39;s session, using a new value for every new customer session.&lt;br&gt; Including this value greatly eases EPS&#39;s internal debugging process for issues with partner requests, as it explicitly links together request paths for individual user&#39;s session. (optional)
     * @param  string $since Required on initial call, not accepted on subsequent paging links provided in response header.&lt;br&gt; The earliest date that a property became inactive to include in the results. ISO 8601 format (YYYY-MM-DD) (optional)
     * @param  string $token Only used for requesting additional pages of data. Provided by the &#x60;next&#x60; URL in the &#x60;Link&#x60; response header. (optional)
     * @param  string $billing_terms This parameter is to specify the terms of how a resulting booking should be billed. If this field is needed, the value for this will be provided to you separately. (optional)
     * @param  string $payment_terms This parameter is to specify what terms should be used when being paid for a resulting booking. If this field is needed, the value for this will be provided to you separately. (optional)
     * @param  string $partner_point_of_sale This parameter is to specify what point of sale is being used to shop and book. If this field is needed, the value for this will be provided to you separately. (optional)
     * @param  string $platform_name This parameter is to specify what platform is being used to shop and book. If this field is needed, the value for this will be provided to you separately. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getInactiveProperties'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getInactivePropertiesAsyncWithHttpInfo($accept, $accept_encoding, $user_agent, $customer_session_id = null, $since = null, $token = null, $billing_terms = null, $payment_terms = null, $partner_point_of_sale = null, $platform_name = null, string $contentType = self::contentTypes['getInactiveProperties'][0])
    {
        $returnType = '\OpenAPI\Client\Model\PropertyInactive[]';
        $request = $this->getInactivePropertiesRequest($accept, $accept_encoding, $user_agent, $customer_session_id, $since, $token, $billing_terms, $payment_terms, $partner_point_of_sale, $platform_name, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getInactiveProperties'
     *
     * @param  string $accept Specifies the response format that the client would like to receive back. This must be &#x60;application/json&#x60;. (required)
     * @param  string $accept_encoding Specifies the response encoding that the client would like to receive back. This must be &#x60;gzip&#x60;. (required)
     * @param  string $user_agent The &#x60;User-Agent&#x60; header string from the customer&#39;s request, as captured by your integration. If you are  building an application then the &#x60;User-Agent&#x60; value should be &#x60;{app name}/{app version}&#x60;. (required)
     * @param  string $customer_session_id Insert your own unique value for each user session, beginning with the first API call. Continue to pass the same value for each subsequent API call during the user&#39;s session, using a new value for every new customer session.&lt;br&gt; Including this value greatly eases EPS&#39;s internal debugging process for issues with partner requests, as it explicitly links together request paths for individual user&#39;s session. (optional)
     * @param  string $since Required on initial call, not accepted on subsequent paging links provided in response header.&lt;br&gt; The earliest date that a property became inactive to include in the results. ISO 8601 format (YYYY-MM-DD) (optional)
     * @param  string $token Only used for requesting additional pages of data. Provided by the &#x60;next&#x60; URL in the &#x60;Link&#x60; response header. (optional)
     * @param  string $billing_terms This parameter is to specify the terms of how a resulting booking should be billed. If this field is needed, the value for this will be provided to you separately. (optional)
     * @param  string $payment_terms This parameter is to specify what terms should be used when being paid for a resulting booking. If this field is needed, the value for this will be provided to you separately. (optional)
     * @param  string $partner_point_of_sale This parameter is to specify what point of sale is being used to shop and book. If this field is needed, the value for this will be provided to you separately. (optional)
     * @param  string $platform_name This parameter is to specify what platform is being used to shop and book. If this field is needed, the value for this will be provided to you separately. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getInactiveProperties'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function getInactivePropertiesRequest($accept, $accept_encoding, $user_agent, $customer_session_id = null, $since = null, $token = null, $billing_terms = null, $payment_terms = null, $partner_point_of_sale = null, $platform_name = null, string $contentType = self::contentTypes['getInactiveProperties'][0])
    {

        // verify the required parameter 'accept' is set
        if ($accept === null || (is_array($accept) && count($accept) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $accept when calling getInactiveProperties'
            );
        }

        // verify the required parameter 'accept_encoding' is set
        if ($accept_encoding === null || (is_array($accept_encoding) && count($accept_encoding) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $accept_encoding when calling getInactiveProperties'
            );
        }

        // verify the required parameter 'user_agent' is set
        if ($user_agent === null || (is_array($user_agent) && count($user_agent) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $user_agent when calling getInactiveProperties'
            );
        }









        $resourcePath = '/properties/inactive';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $since,
            'since', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $token,
            'token', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $billing_terms,
            'billing_terms', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $payment_terms,
            'payment_terms', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $partner_point_of_sale,
            'partner_point_of_sale', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $platform_name,
            'platform_name', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);

        // header params
        if ($accept !== null) {
            $headerParams['Accept'] = ObjectSerializer::toHeaderValue($accept);
        }
        // header params
        if ($accept_encoding !== null) {
            $headerParams['Accept-Encoding'] = ObjectSerializer::toHeaderValue($accept_encoding);
        }
        // header params
        if ($user_agent !== null) {
            $headerParams['User-Agent'] = ObjectSerializer::toHeaderValue($user_agent);
        }
        // header params
        if ($customer_session_id !== null) {
            $headerParams['Customer-Session-Id'] = ObjectSerializer::toHeaderValue($customer_session_id);
        }



        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getPropertyCatalogFile
     *
     * Property Catalog File
     *
     * @param  string $accept Specifies the response format that the client would like to receive back. This must be &#x60;application/json&#x60;. (required)
     * @param  string $accept_encoding Specifies the response encoding that the client would like to receive back. This must be &#x60;gzip&#x60;. (required)
     * @param  string $user_agent The &#x60;User-Agent&#x60; header string from the customer&#39;s request, as captured by your integration. If you are building an application then the &#x60;User-Agent&#x60; value should be &#x60;{app name}/{app version}&#x60;. (required)
     * @param  string $language Desired language for the response as a subset of BCP47 format that only uses hyphenated pairs of two-digit language and country codes. Use only ISO 639-1 alpha-2 language codes and ISO 3166-1 alpha-2 country codes. See [https://www.w3.org/International/articles/language-tags/](https://www.w3.org/International/articles/language-tags/)  Language Options: [https://developers.expediagroup.com/docs/rapid/resources/reference/language-options](https://developers.expediagroup.com/docs/rapid/resources/reference/language-options) (required)
     * @param  string $supply_source Options for which supply source you would like returned in the content response. This parameter may only be supplied once and will return all properties that match the requested supply source. An error is thrown if the parameter is provided multiple times.   * &#x60;expedia&#x60; - Standard Expedia supply.   * &#x60;vrbo&#x60; - VRBO supply - This option is restricted to partners who have VRBO supply enabled for their profile. See [Vacation Rentals](https://developers.expediagroup.com/docs/rapid/lodging/vacation-rentals) for more information. (required)
     * @param  string $customer_session_id Insert your own unique value for each user session, beginning with the first API call. Continue to pass the same value for each subsequent API call during the user&#39;s session, using a new value for every new customer session.&lt;br&gt; Including this value greatly eases EPS&#39;s internal debugging process for issues with partner requests, as it explicitly links together request paths for individual user&#39;s session. (optional)
     * @param  string $billing_terms This parameter is to specify the terms of how a resulting booking should be billed. If this field is needed, the value for this will be provided to you separately. (optional)
     * @param  string $payment_terms This parameter is to specify what terms should be used when being paid for a resulting booking. If this field is needed, the value for this will be provided to you separately. (optional)
     * @param  string $partner_point_of_sale This parameter is to specify what point of sale is being used to shop and book. If this field is needed, the value for this will be provided to you separately. (optional)
     * @param  string $platform_name This parameter is to specify what platform is being used to shop and book. If this field is needed, the value for this will be provided to you separately. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getPropertyCatalogFile'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\Link|\OpenAPI\Client\Model\Error|\OpenAPI\Client\Model\Error|\OpenAPI\Client\Model\Error|\OpenAPI\Client\Model\Error|\OpenAPI\Client\Model\Error|\OpenAPI\Client\Model\Error|\OpenAPI\Client\Model\Error|\OpenAPI\Client\Model\Error
     */
    public function getPropertyCatalogFile($accept, $accept_encoding, $user_agent, $language, $supply_source, $customer_session_id = null, $billing_terms = null, $payment_terms = null, $partner_point_of_sale = null, $platform_name = null, string $contentType = self::contentTypes['getPropertyCatalogFile'][0])
    {
        list($response) = $this->getPropertyCatalogFileWithHttpInfo($accept, $accept_encoding, $user_agent, $language, $supply_source, $customer_session_id, $billing_terms, $payment_terms, $partner_point_of_sale, $platform_name, $contentType);
        return $response;
    }

    /**
     * Operation getPropertyCatalogFileWithHttpInfo
     *
     * Property Catalog File
     *
     * @param  string $accept Specifies the response format that the client would like to receive back. This must be &#x60;application/json&#x60;. (required)
     * @param  string $accept_encoding Specifies the response encoding that the client would like to receive back. This must be &#x60;gzip&#x60;. (required)
     * @param  string $user_agent The &#x60;User-Agent&#x60; header string from the customer&#39;s request, as captured by your integration. If you are building an application then the &#x60;User-Agent&#x60; value should be &#x60;{app name}/{app version}&#x60;. (required)
     * @param  string $language Desired language for the response as a subset of BCP47 format that only uses hyphenated pairs of two-digit language and country codes. Use only ISO 639-1 alpha-2 language codes and ISO 3166-1 alpha-2 country codes. See [https://www.w3.org/International/articles/language-tags/](https://www.w3.org/International/articles/language-tags/)  Language Options: [https://developers.expediagroup.com/docs/rapid/resources/reference/language-options](https://developers.expediagroup.com/docs/rapid/resources/reference/language-options) (required)
     * @param  string $supply_source Options for which supply source you would like returned in the content response. This parameter may only be supplied once and will return all properties that match the requested supply source. An error is thrown if the parameter is provided multiple times.   * &#x60;expedia&#x60; - Standard Expedia supply.   * &#x60;vrbo&#x60; - VRBO supply - This option is restricted to partners who have VRBO supply enabled for their profile. See [Vacation Rentals](https://developers.expediagroup.com/docs/rapid/lodging/vacation-rentals) for more information. (required)
     * @param  string $customer_session_id Insert your own unique value for each user session, beginning with the first API call. Continue to pass the same value for each subsequent API call during the user&#39;s session, using a new value for every new customer session.&lt;br&gt; Including this value greatly eases EPS&#39;s internal debugging process for issues with partner requests, as it explicitly links together request paths for individual user&#39;s session. (optional)
     * @param  string $billing_terms This parameter is to specify the terms of how a resulting booking should be billed. If this field is needed, the value for this will be provided to you separately. (optional)
     * @param  string $payment_terms This parameter is to specify what terms should be used when being paid for a resulting booking. If this field is needed, the value for this will be provided to you separately. (optional)
     * @param  string $partner_point_of_sale This parameter is to specify what point of sale is being used to shop and book. If this field is needed, the value for this will be provided to you separately. (optional)
     * @param  string $platform_name This parameter is to specify what platform is being used to shop and book. If this field is needed, the value for this will be provided to you separately. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getPropertyCatalogFile'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\Link|\OpenAPI\Client\Model\Error|\OpenAPI\Client\Model\Error|\OpenAPI\Client\Model\Error|\OpenAPI\Client\Model\Error|\OpenAPI\Client\Model\Error|\OpenAPI\Client\Model\Error|\OpenAPI\Client\Model\Error|\OpenAPI\Client\Model\Error, HTTP status code, HTTP response headers (array of strings)
     */
    public function getPropertyCatalogFileWithHttpInfo($accept, $accept_encoding, $user_agent, $language, $supply_source, $customer_session_id = null, $billing_terms = null, $payment_terms = null, $partner_point_of_sale = null, $platform_name = null, string $contentType = self::contentTypes['getPropertyCatalogFile'][0])
    {
        $request = $this->getPropertyCatalogFileRequest($accept, $accept_encoding, $user_agent, $language, $supply_source, $customer_session_id, $billing_terms, $payment_terms, $partner_point_of_sale, $platform_name, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\Link' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\Link' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\Link', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 400:
                    if ('\OpenAPI\Client\Model\Error' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\Error' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\Error', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 401:
                    if ('\OpenAPI\Client\Model\Error' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\Error' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\Error', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 403:
                    if ('\OpenAPI\Client\Model\Error' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\Error' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\Error', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 404:
                    if ('\OpenAPI\Client\Model\Error' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\Error' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\Error', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 426:
                    if ('\OpenAPI\Client\Model\Error' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\Error' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\Error', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 429:
                    if ('\OpenAPI\Client\Model\Error' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\Error' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\Error', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 500:
                    if ('\OpenAPI\Client\Model\Error' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\Error' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\Error', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 503:
                    if ('\OpenAPI\Client\Model\Error' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\Error' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\Error', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\Link';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\Link',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\Error',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 401:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\Error',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 403:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\Error',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 404:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\Error',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 426:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\Error',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 429:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\Error',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 500:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\Error',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 503:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\Error',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getPropertyCatalogFileAsync
     *
     * Property Catalog File
     *
     * @param  string $accept Specifies the response format that the client would like to receive back. This must be &#x60;application/json&#x60;. (required)
     * @param  string $accept_encoding Specifies the response encoding that the client would like to receive back. This must be &#x60;gzip&#x60;. (required)
     * @param  string $user_agent The &#x60;User-Agent&#x60; header string from the customer&#39;s request, as captured by your integration. If you are building an application then the &#x60;User-Agent&#x60; value should be &#x60;{app name}/{app version}&#x60;. (required)
     * @param  string $language Desired language for the response as a subset of BCP47 format that only uses hyphenated pairs of two-digit language and country codes. Use only ISO 639-1 alpha-2 language codes and ISO 3166-1 alpha-2 country codes. See [https://www.w3.org/International/articles/language-tags/](https://www.w3.org/International/articles/language-tags/)  Language Options: [https://developers.expediagroup.com/docs/rapid/resources/reference/language-options](https://developers.expediagroup.com/docs/rapid/resources/reference/language-options) (required)
     * @param  string $supply_source Options for which supply source you would like returned in the content response. This parameter may only be supplied once and will return all properties that match the requested supply source. An error is thrown if the parameter is provided multiple times.   * &#x60;expedia&#x60; - Standard Expedia supply.   * &#x60;vrbo&#x60; - VRBO supply - This option is restricted to partners who have VRBO supply enabled for their profile. See [Vacation Rentals](https://developers.expediagroup.com/docs/rapid/lodging/vacation-rentals) for more information. (required)
     * @param  string $customer_session_id Insert your own unique value for each user session, beginning with the first API call. Continue to pass the same value for each subsequent API call during the user&#39;s session, using a new value for every new customer session.&lt;br&gt; Including this value greatly eases EPS&#39;s internal debugging process for issues with partner requests, as it explicitly links together request paths for individual user&#39;s session. (optional)
     * @param  string $billing_terms This parameter is to specify the terms of how a resulting booking should be billed. If this field is needed, the value for this will be provided to you separately. (optional)
     * @param  string $payment_terms This parameter is to specify what terms should be used when being paid for a resulting booking. If this field is needed, the value for this will be provided to you separately. (optional)
     * @param  string $partner_point_of_sale This parameter is to specify what point of sale is being used to shop and book. If this field is needed, the value for this will be provided to you separately. (optional)
     * @param  string $platform_name This parameter is to specify what platform is being used to shop and book. If this field is needed, the value for this will be provided to you separately. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getPropertyCatalogFile'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getPropertyCatalogFileAsync($accept, $accept_encoding, $user_agent, $language, $supply_source, $customer_session_id = null, $billing_terms = null, $payment_terms = null, $partner_point_of_sale = null, $platform_name = null, string $contentType = self::contentTypes['getPropertyCatalogFile'][0])
    {
        return $this->getPropertyCatalogFileAsyncWithHttpInfo($accept, $accept_encoding, $user_agent, $language, $supply_source, $customer_session_id, $billing_terms, $payment_terms, $partner_point_of_sale, $platform_name, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getPropertyCatalogFileAsyncWithHttpInfo
     *
     * Property Catalog File
     *
     * @param  string $accept Specifies the response format that the client would like to receive back. This must be &#x60;application/json&#x60;. (required)
     * @param  string $accept_encoding Specifies the response encoding that the client would like to receive back. This must be &#x60;gzip&#x60;. (required)
     * @param  string $user_agent The &#x60;User-Agent&#x60; header string from the customer&#39;s request, as captured by your integration. If you are building an application then the &#x60;User-Agent&#x60; value should be &#x60;{app name}/{app version}&#x60;. (required)
     * @param  string $language Desired language for the response as a subset of BCP47 format that only uses hyphenated pairs of two-digit language and country codes. Use only ISO 639-1 alpha-2 language codes and ISO 3166-1 alpha-2 country codes. See [https://www.w3.org/International/articles/language-tags/](https://www.w3.org/International/articles/language-tags/)  Language Options: [https://developers.expediagroup.com/docs/rapid/resources/reference/language-options](https://developers.expediagroup.com/docs/rapid/resources/reference/language-options) (required)
     * @param  string $supply_source Options for which supply source you would like returned in the content response. This parameter may only be supplied once and will return all properties that match the requested supply source. An error is thrown if the parameter is provided multiple times.   * &#x60;expedia&#x60; - Standard Expedia supply.   * &#x60;vrbo&#x60; - VRBO supply - This option is restricted to partners who have VRBO supply enabled for their profile. See [Vacation Rentals](https://developers.expediagroup.com/docs/rapid/lodging/vacation-rentals) for more information. (required)
     * @param  string $customer_session_id Insert your own unique value for each user session, beginning with the first API call. Continue to pass the same value for each subsequent API call during the user&#39;s session, using a new value for every new customer session.&lt;br&gt; Including this value greatly eases EPS&#39;s internal debugging process for issues with partner requests, as it explicitly links together request paths for individual user&#39;s session. (optional)
     * @param  string $billing_terms This parameter is to specify the terms of how a resulting booking should be billed. If this field is needed, the value for this will be provided to you separately. (optional)
     * @param  string $payment_terms This parameter is to specify what terms should be used when being paid for a resulting booking. If this field is needed, the value for this will be provided to you separately. (optional)
     * @param  string $partner_point_of_sale This parameter is to specify what point of sale is being used to shop and book. If this field is needed, the value for this will be provided to you separately. (optional)
     * @param  string $platform_name This parameter is to specify what platform is being used to shop and book. If this field is needed, the value for this will be provided to you separately. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getPropertyCatalogFile'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getPropertyCatalogFileAsyncWithHttpInfo($accept, $accept_encoding, $user_agent, $language, $supply_source, $customer_session_id = null, $billing_terms = null, $payment_terms = null, $partner_point_of_sale = null, $platform_name = null, string $contentType = self::contentTypes['getPropertyCatalogFile'][0])
    {
        $returnType = '\OpenAPI\Client\Model\Link';
        $request = $this->getPropertyCatalogFileRequest($accept, $accept_encoding, $user_agent, $language, $supply_source, $customer_session_id, $billing_terms, $payment_terms, $partner_point_of_sale, $platform_name, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getPropertyCatalogFile'
     *
     * @param  string $accept Specifies the response format that the client would like to receive back. This must be &#x60;application/json&#x60;. (required)
     * @param  string $accept_encoding Specifies the response encoding that the client would like to receive back. This must be &#x60;gzip&#x60;. (required)
     * @param  string $user_agent The &#x60;User-Agent&#x60; header string from the customer&#39;s request, as captured by your integration. If you are building an application then the &#x60;User-Agent&#x60; value should be &#x60;{app name}/{app version}&#x60;. (required)
     * @param  string $language Desired language for the response as a subset of BCP47 format that only uses hyphenated pairs of two-digit language and country codes. Use only ISO 639-1 alpha-2 language codes and ISO 3166-1 alpha-2 country codes. See [https://www.w3.org/International/articles/language-tags/](https://www.w3.org/International/articles/language-tags/)  Language Options: [https://developers.expediagroup.com/docs/rapid/resources/reference/language-options](https://developers.expediagroup.com/docs/rapid/resources/reference/language-options) (required)
     * @param  string $supply_source Options for which supply source you would like returned in the content response. This parameter may only be supplied once and will return all properties that match the requested supply source. An error is thrown if the parameter is provided multiple times.   * &#x60;expedia&#x60; - Standard Expedia supply.   * &#x60;vrbo&#x60; - VRBO supply - This option is restricted to partners who have VRBO supply enabled for their profile. See [Vacation Rentals](https://developers.expediagroup.com/docs/rapid/lodging/vacation-rentals) for more information. (required)
     * @param  string $customer_session_id Insert your own unique value for each user session, beginning with the first API call. Continue to pass the same value for each subsequent API call during the user&#39;s session, using a new value for every new customer session.&lt;br&gt; Including this value greatly eases EPS&#39;s internal debugging process for issues with partner requests, as it explicitly links together request paths for individual user&#39;s session. (optional)
     * @param  string $billing_terms This parameter is to specify the terms of how a resulting booking should be billed. If this field is needed, the value for this will be provided to you separately. (optional)
     * @param  string $payment_terms This parameter is to specify what terms should be used when being paid for a resulting booking. If this field is needed, the value for this will be provided to you separately. (optional)
     * @param  string $partner_point_of_sale This parameter is to specify what point of sale is being used to shop and book. If this field is needed, the value for this will be provided to you separately. (optional)
     * @param  string $platform_name This parameter is to specify what platform is being used to shop and book. If this field is needed, the value for this will be provided to you separately. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getPropertyCatalogFile'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function getPropertyCatalogFileRequest($accept, $accept_encoding, $user_agent, $language, $supply_source, $customer_session_id = null, $billing_terms = null, $payment_terms = null, $partner_point_of_sale = null, $platform_name = null, string $contentType = self::contentTypes['getPropertyCatalogFile'][0])
    {

        // verify the required parameter 'accept' is set
        if ($accept === null || (is_array($accept) && count($accept) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $accept when calling getPropertyCatalogFile'
            );
        }

        // verify the required parameter 'accept_encoding' is set
        if ($accept_encoding === null || (is_array($accept_encoding) && count($accept_encoding) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $accept_encoding when calling getPropertyCatalogFile'
            );
        }

        // verify the required parameter 'user_agent' is set
        if ($user_agent === null || (is_array($user_agent) && count($user_agent) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $user_agent when calling getPropertyCatalogFile'
            );
        }

        // verify the required parameter 'language' is set
        if ($language === null || (is_array($language) && count($language) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $language when calling getPropertyCatalogFile'
            );
        }

        // verify the required parameter 'supply_source' is set
        if ($supply_source === null || (is_array($supply_source) && count($supply_source) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $supply_source when calling getPropertyCatalogFile'
            );
        }







        $resourcePath = '/files/properties/catalog';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $language,
            'language', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            true // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $supply_source,
            'supply_source', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            true // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $billing_terms,
            'billing_terms', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $payment_terms,
            'payment_terms', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $partner_point_of_sale,
            'partner_point_of_sale', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $platform_name,
            'platform_name', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);

        // header params
        if ($accept !== null) {
            $headerParams['Accept'] = ObjectSerializer::toHeaderValue($accept);
        }
        // header params
        if ($accept_encoding !== null) {
            $headerParams['Accept-Encoding'] = ObjectSerializer::toHeaderValue($accept_encoding);
        }
        // header params
        if ($customer_session_id !== null) {
            $headerParams['Customer-Session-Id'] = ObjectSerializer::toHeaderValue($customer_session_id);
        }
        // header params
        if ($user_agent !== null) {
            $headerParams['User-Agent'] = ObjectSerializer::toHeaderValue($user_agent);
        }



        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getPropertyContent
     *
     * Property Content
     *
     * @param  string $accept Specifies the response format that the client would like to receive back. This must be &#x60;application/json&#x60;. (required)
     * @param  string $accept_encoding Specifies the response encoding that the client would like to receive back. This must be &#x60;gzip&#x60;. (required)
     * @param  string $user_agent The &#x60;User-Agent&#x60; header string from the customer&#39;s request, as captured by your integration. If you are building an application then the &#x60;User-Agent&#x60; value should be &#x60;{app name}/{app version}&#x60;. (required)
     * @param  string $language Desired language for the response as a subset of BCP47 format that only uses hyphenated pairs of two-digit language and country codes. Use only ISO 639-1 alpha-2 language codes and ISO 3166-1 alpha-2 country codes. See [https://www.w3.org/International/articles/language-tags/](https://www.w3.org/International/articles/language-tags/)  Language Options: [https://developers.expediagroup.com/docs/rapid/resources/reference/language-options](https://developers.expediagroup.com/docs/rapid/resources/reference/language-options) (required)
     * @param  string $supply_source Options for which supply source you would like returned in the content response. This parameter may only be supplied once and will return all properties that match the requested supply source. An error is thrown if the parameter is provided multiple times.   * &#x60;expedia&#x60; - Standard Expedia supply.   * &#x60;vrbo&#x60; - VRBO supply - This option is restricted to partners who have VRBO supply enabled for their profile. See [Vacation Rentals](https://developers.expediagroup.com/docs/rapid/lodging/vacation-rentals) for more information. (required)
     * @param  string $customer_session_id Insert your own unique value for each user session, beginning with the first API call. Continue to pass the same value for each subsequent API call during the user&#39;s session, using a new value for every new customer session.&lt;br&gt; Including this value greatly eases EPS&#39;s internal debugging process for issues with partner requests, as it explicitly links together request paths for individual user&#39;s session. (optional)
     * @param  string[] $brand_id The ID of the brand you want to search for. This parameter can be supplied multiple times with different values, which will include properties that match any of the requested brand IDs. (optional)
     * @param  string[] $business_model Search for properties with the requested business model enabled. This parameter can be supplied multiple times with different values, which will return all properties that match any of the requested business models. The value must be lower case.  Possible values:   * expedia_collect - Return only properties where the payment is collected by Expedia.   * property_collect - Return only properties where the payment is collected at the property. (optional)
     * @param  string[] $category_id_exclude Search to exclude properties that do not have the requested [category ID](https://developers.expediagroup.com/docs/rapid/lodging/content/content-reference-lists). If this parameter is not supplied, all category IDs are included. This parameter can be supplied multiple times with different values, which will exclude properties that match any of the requested category IDs. (optional)
     * @param  string[] $chain_id The ID of the chain you want to search for. These chain IDs can be positive and negative numbers. This parameter can be supplied multiple times with different values, which will include properties that match any of the requested chain IDs. (optional)
     * @param  string[] $country_code Search for properties with the requested country code, in ISO 3166-1 alpha-2 format. This parameter can be supplied multiple times with different values, which will include properties that match any of the requested country codes. (optional)
     * @param  string $date_added_end Search for properties added on or before the requested UTC date, in ISO 8601 format (YYYY-MM-DD) (optional)
     * @param  string $date_added_start Search for properties added on or after the requested UTC date, in ISO 8601 format (YYYY-MM-DD) (optional)
     * @param  string $date_updated_end Search for properties updated on or before the requested UTC date, in ISO 8601 format (YYYY-MM-DD) (optional)
     * @param  string $date_updated_start Search for properties updated on or after the requested UTC date, in ISO 8601 format (YYYY-MM-DD) (optional)
     * @param  string[] $include Option for limiting what fields to return in the response. The value must be lower case. This parameter can be supplied multiple times with different values, which will return a combination of all fields asked for.  Possible values:  * property_ids - Return only the property id of the property object.  * catalog - Return only the property catalog property-level fields.  * address - Returns only the address fields. (optional)
     * @param  bool $multi_unit Search for multi-unit properties. If this parameter is not supplied, both single-unit and multi-unit properties will be included.  Possible values:   * true - Include only properties that are multi-unit.   * false - Do not include properties that are multi-unit. (optional)
     * @param  string[] $property_id The ID of the property you want to search for. You can provide 1 to 250 property_id parameters. (optional)
     * @param  string $property_rating_max Search for properties with a property rating less than or equal to the requested rating. The highest property rating value is 5.0. (optional)
     * @param  string $property_rating_min Search for properties with a property rating greater than or equal to the requested rating. The lowest property rating value is 0.0. (optional)
     * @param  string $billing_terms This parameter is to specify the terms of how a resulting booking should be billed. If this field is needed, the value for this will be provided to you separately. (optional)
     * @param  string $partner_point_of_sale This parameter is to specify what point of sale is being used to shop and book. If this field is needed, the value for this will be provided to you separately. (optional)
     * @param  string $payment_terms This parameter is to specify what terms should be used when being paid for a resulting booking. If this field is needed, the value for this will be provided to you separately. (optional)
     * @param  string $platform_name This parameter is to specify what platform is being used to shop and book. If this field is needed, the value for this will be provided to you separately. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getPropertyContent'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array<string,\OpenAPI\Client\Model\PropertyContent>|\OpenAPI\Client\Model\Error|\OpenAPI\Client\Model\Error|\OpenAPI\Client\Model\Error|\OpenAPI\Client\Model\Error|\OpenAPI\Client\Model\Error|\OpenAPI\Client\Model\Error|\OpenAPI\Client\Model\Error|\OpenAPI\Client\Model\Error
     */
    public function getPropertyContent($accept, $accept_encoding, $user_agent, $language, $supply_source, $customer_session_id = null, $brand_id = null, $business_model = null, $category_id_exclude = null, $chain_id = null, $country_code = null, $date_added_end = null, $date_added_start = null, $date_updated_end = null, $date_updated_start = null, $include = null, $multi_unit = null, $property_id = null, $property_rating_max = null, $property_rating_min = null, $billing_terms = null, $partner_point_of_sale = null, $payment_terms = null, $platform_name = null, string $contentType = self::contentTypes['getPropertyContent'][0])
    {
        list($response) = $this->getPropertyContentWithHttpInfo($accept, $accept_encoding, $user_agent, $language, $supply_source, $customer_session_id, $brand_id, $business_model, $category_id_exclude, $chain_id, $country_code, $date_added_end, $date_added_start, $date_updated_end, $date_updated_start, $include, $multi_unit, $property_id, $property_rating_max, $property_rating_min, $billing_terms, $partner_point_of_sale, $payment_terms, $platform_name, $contentType);
        return $response;
    }

    /**
     * Operation getPropertyContentWithHttpInfo
     *
     * Property Content
     *
     * @param  string $accept Specifies the response format that the client would like to receive back. This must be &#x60;application/json&#x60;. (required)
     * @param  string $accept_encoding Specifies the response encoding that the client would like to receive back. This must be &#x60;gzip&#x60;. (required)
     * @param  string $user_agent The &#x60;User-Agent&#x60; header string from the customer&#39;s request, as captured by your integration. If you are building an application then the &#x60;User-Agent&#x60; value should be &#x60;{app name}/{app version}&#x60;. (required)
     * @param  string $language Desired language for the response as a subset of BCP47 format that only uses hyphenated pairs of two-digit language and country codes. Use only ISO 639-1 alpha-2 language codes and ISO 3166-1 alpha-2 country codes. See [https://www.w3.org/International/articles/language-tags/](https://www.w3.org/International/articles/language-tags/)  Language Options: [https://developers.expediagroup.com/docs/rapid/resources/reference/language-options](https://developers.expediagroup.com/docs/rapid/resources/reference/language-options) (required)
     * @param  string $supply_source Options for which supply source you would like returned in the content response. This parameter may only be supplied once and will return all properties that match the requested supply source. An error is thrown if the parameter is provided multiple times.   * &#x60;expedia&#x60; - Standard Expedia supply.   * &#x60;vrbo&#x60; - VRBO supply - This option is restricted to partners who have VRBO supply enabled for their profile. See [Vacation Rentals](https://developers.expediagroup.com/docs/rapid/lodging/vacation-rentals) for more information. (required)
     * @param  string $customer_session_id Insert your own unique value for each user session, beginning with the first API call. Continue to pass the same value for each subsequent API call during the user&#39;s session, using a new value for every new customer session.&lt;br&gt; Including this value greatly eases EPS&#39;s internal debugging process for issues with partner requests, as it explicitly links together request paths for individual user&#39;s session. (optional)
     * @param  string[] $brand_id The ID of the brand you want to search for. This parameter can be supplied multiple times with different values, which will include properties that match any of the requested brand IDs. (optional)
     * @param  string[] $business_model Search for properties with the requested business model enabled. This parameter can be supplied multiple times with different values, which will return all properties that match any of the requested business models. The value must be lower case.  Possible values:   * expedia_collect - Return only properties where the payment is collected by Expedia.   * property_collect - Return only properties where the payment is collected at the property. (optional)
     * @param  string[] $category_id_exclude Search to exclude properties that do not have the requested [category ID](https://developers.expediagroup.com/docs/rapid/lodging/content/content-reference-lists). If this parameter is not supplied, all category IDs are included. This parameter can be supplied multiple times with different values, which will exclude properties that match any of the requested category IDs. (optional)
     * @param  string[] $chain_id The ID of the chain you want to search for. These chain IDs can be positive and negative numbers. This parameter can be supplied multiple times with different values, which will include properties that match any of the requested chain IDs. (optional)
     * @param  string[] $country_code Search for properties with the requested country code, in ISO 3166-1 alpha-2 format. This parameter can be supplied multiple times with different values, which will include properties that match any of the requested country codes. (optional)
     * @param  string $date_added_end Search for properties added on or before the requested UTC date, in ISO 8601 format (YYYY-MM-DD) (optional)
     * @param  string $date_added_start Search for properties added on or after the requested UTC date, in ISO 8601 format (YYYY-MM-DD) (optional)
     * @param  string $date_updated_end Search for properties updated on or before the requested UTC date, in ISO 8601 format (YYYY-MM-DD) (optional)
     * @param  string $date_updated_start Search for properties updated on or after the requested UTC date, in ISO 8601 format (YYYY-MM-DD) (optional)
     * @param  string[] $include Option for limiting what fields to return in the response. The value must be lower case. This parameter can be supplied multiple times with different values, which will return a combination of all fields asked for.  Possible values:  * property_ids - Return only the property id of the property object.  * catalog - Return only the property catalog property-level fields.  * address - Returns only the address fields. (optional)
     * @param  bool $multi_unit Search for multi-unit properties. If this parameter is not supplied, both single-unit and multi-unit properties will be included.  Possible values:   * true - Include only properties that are multi-unit.   * false - Do not include properties that are multi-unit. (optional)
     * @param  string[] $property_id The ID of the property you want to search for. You can provide 1 to 250 property_id parameters. (optional)
     * @param  string $property_rating_max Search for properties with a property rating less than or equal to the requested rating. The highest property rating value is 5.0. (optional)
     * @param  string $property_rating_min Search for properties with a property rating greater than or equal to the requested rating. The lowest property rating value is 0.0. (optional)
     * @param  string $billing_terms This parameter is to specify the terms of how a resulting booking should be billed. If this field is needed, the value for this will be provided to you separately. (optional)
     * @param  string $partner_point_of_sale This parameter is to specify what point of sale is being used to shop and book. If this field is needed, the value for this will be provided to you separately. (optional)
     * @param  string $payment_terms This parameter is to specify what terms should be used when being paid for a resulting booking. If this field is needed, the value for this will be provided to you separately. (optional)
     * @param  string $platform_name This parameter is to specify what platform is being used to shop and book. If this field is needed, the value for this will be provided to you separately. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getPropertyContent'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of array<string,\OpenAPI\Client\Model\PropertyContent>|\OpenAPI\Client\Model\Error|\OpenAPI\Client\Model\Error|\OpenAPI\Client\Model\Error|\OpenAPI\Client\Model\Error|\OpenAPI\Client\Model\Error|\OpenAPI\Client\Model\Error|\OpenAPI\Client\Model\Error|\OpenAPI\Client\Model\Error, HTTP status code, HTTP response headers (array of strings)
     */
    public function getPropertyContentWithHttpInfo($accept, $accept_encoding, $user_agent, $language, $supply_source, $customer_session_id = null, $brand_id = null, $business_model = null, $category_id_exclude = null, $chain_id = null, $country_code = null, $date_added_end = null, $date_added_start = null, $date_updated_end = null, $date_updated_start = null, $include = null, $multi_unit = null, $property_id = null, $property_rating_max = null, $property_rating_min = null, $billing_terms = null, $partner_point_of_sale = null, $payment_terms = null, $platform_name = null, string $contentType = self::contentTypes['getPropertyContent'][0])
    {
        $request = $this->getPropertyContentRequest($accept, $accept_encoding, $user_agent, $language, $supply_source, $customer_session_id, $brand_id, $business_model, $category_id_exclude, $chain_id, $country_code, $date_added_end, $date_added_start, $date_updated_end, $date_updated_start, $include, $multi_unit, $property_id, $property_rating_max, $property_rating_min, $billing_terms, $partner_point_of_sale, $payment_terms, $platform_name, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('array<string,\OpenAPI\Client\Model\PropertyContent>' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('array<string,\OpenAPI\Client\Model\PropertyContent>' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, 'array<string,\OpenAPI\Client\Model\PropertyContent>', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 400:
                    if ('\OpenAPI\Client\Model\Error' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\Error' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\Error', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 401:
                    if ('\OpenAPI\Client\Model\Error' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\Error' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\Error', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 403:
                    if ('\OpenAPI\Client\Model\Error' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\Error' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\Error', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 410:
                    if ('\OpenAPI\Client\Model\Error' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\Error' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\Error', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 426:
                    if ('\OpenAPI\Client\Model\Error' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\Error' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\Error', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 429:
                    if ('\OpenAPI\Client\Model\Error' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\Error' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\Error', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 500:
                    if ('\OpenAPI\Client\Model\Error' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\Error' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\Error', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 503:
                    if ('\OpenAPI\Client\Model\Error' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\Error' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\Error', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = 'array<string,\OpenAPI\Client\Model\PropertyContent>';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'array<string,\OpenAPI\Client\Model\PropertyContent>',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\Error',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 401:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\Error',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 403:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\Error',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 410:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\Error',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 426:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\Error',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 429:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\Error',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 500:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\Error',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 503:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\Error',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getPropertyContentAsync
     *
     * Property Content
     *
     * @param  string $accept Specifies the response format that the client would like to receive back. This must be &#x60;application/json&#x60;. (required)
     * @param  string $accept_encoding Specifies the response encoding that the client would like to receive back. This must be &#x60;gzip&#x60;. (required)
     * @param  string $user_agent The &#x60;User-Agent&#x60; header string from the customer&#39;s request, as captured by your integration. If you are building an application then the &#x60;User-Agent&#x60; value should be &#x60;{app name}/{app version}&#x60;. (required)
     * @param  string $language Desired language for the response as a subset of BCP47 format that only uses hyphenated pairs of two-digit language and country codes. Use only ISO 639-1 alpha-2 language codes and ISO 3166-1 alpha-2 country codes. See [https://www.w3.org/International/articles/language-tags/](https://www.w3.org/International/articles/language-tags/)  Language Options: [https://developers.expediagroup.com/docs/rapid/resources/reference/language-options](https://developers.expediagroup.com/docs/rapid/resources/reference/language-options) (required)
     * @param  string $supply_source Options for which supply source you would like returned in the content response. This parameter may only be supplied once and will return all properties that match the requested supply source. An error is thrown if the parameter is provided multiple times.   * &#x60;expedia&#x60; - Standard Expedia supply.   * &#x60;vrbo&#x60; - VRBO supply - This option is restricted to partners who have VRBO supply enabled for their profile. See [Vacation Rentals](https://developers.expediagroup.com/docs/rapid/lodging/vacation-rentals) for more information. (required)
     * @param  string $customer_session_id Insert your own unique value for each user session, beginning with the first API call. Continue to pass the same value for each subsequent API call during the user&#39;s session, using a new value for every new customer session.&lt;br&gt; Including this value greatly eases EPS&#39;s internal debugging process for issues with partner requests, as it explicitly links together request paths for individual user&#39;s session. (optional)
     * @param  string[] $brand_id The ID of the brand you want to search for. This parameter can be supplied multiple times with different values, which will include properties that match any of the requested brand IDs. (optional)
     * @param  string[] $business_model Search for properties with the requested business model enabled. This parameter can be supplied multiple times with different values, which will return all properties that match any of the requested business models. The value must be lower case.  Possible values:   * expedia_collect - Return only properties where the payment is collected by Expedia.   * property_collect - Return only properties where the payment is collected at the property. (optional)
     * @param  string[] $category_id_exclude Search to exclude properties that do not have the requested [category ID](https://developers.expediagroup.com/docs/rapid/lodging/content/content-reference-lists). If this parameter is not supplied, all category IDs are included. This parameter can be supplied multiple times with different values, which will exclude properties that match any of the requested category IDs. (optional)
     * @param  string[] $chain_id The ID of the chain you want to search for. These chain IDs can be positive and negative numbers. This parameter can be supplied multiple times with different values, which will include properties that match any of the requested chain IDs. (optional)
     * @param  string[] $country_code Search for properties with the requested country code, in ISO 3166-1 alpha-2 format. This parameter can be supplied multiple times with different values, which will include properties that match any of the requested country codes. (optional)
     * @param  string $date_added_end Search for properties added on or before the requested UTC date, in ISO 8601 format (YYYY-MM-DD) (optional)
     * @param  string $date_added_start Search for properties added on or after the requested UTC date, in ISO 8601 format (YYYY-MM-DD) (optional)
     * @param  string $date_updated_end Search for properties updated on or before the requested UTC date, in ISO 8601 format (YYYY-MM-DD) (optional)
     * @param  string $date_updated_start Search for properties updated on or after the requested UTC date, in ISO 8601 format (YYYY-MM-DD) (optional)
     * @param  string[] $include Option for limiting what fields to return in the response. The value must be lower case. This parameter can be supplied multiple times with different values, which will return a combination of all fields asked for.  Possible values:  * property_ids - Return only the property id of the property object.  * catalog - Return only the property catalog property-level fields.  * address - Returns only the address fields. (optional)
     * @param  bool $multi_unit Search for multi-unit properties. If this parameter is not supplied, both single-unit and multi-unit properties will be included.  Possible values:   * true - Include only properties that are multi-unit.   * false - Do not include properties that are multi-unit. (optional)
     * @param  string[] $property_id The ID of the property you want to search for. You can provide 1 to 250 property_id parameters. (optional)
     * @param  string $property_rating_max Search for properties with a property rating less than or equal to the requested rating. The highest property rating value is 5.0. (optional)
     * @param  string $property_rating_min Search for properties with a property rating greater than or equal to the requested rating. The lowest property rating value is 0.0. (optional)
     * @param  string $billing_terms This parameter is to specify the terms of how a resulting booking should be billed. If this field is needed, the value for this will be provided to you separately. (optional)
     * @param  string $partner_point_of_sale This parameter is to specify what point of sale is being used to shop and book. If this field is needed, the value for this will be provided to you separately. (optional)
     * @param  string $payment_terms This parameter is to specify what terms should be used when being paid for a resulting booking. If this field is needed, the value for this will be provided to you separately. (optional)
     * @param  string $platform_name This parameter is to specify what platform is being used to shop and book. If this field is needed, the value for this will be provided to you separately. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getPropertyContent'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getPropertyContentAsync($accept, $accept_encoding, $user_agent, $language, $supply_source, $customer_session_id = null, $brand_id = null, $business_model = null, $category_id_exclude = null, $chain_id = null, $country_code = null, $date_added_end = null, $date_added_start = null, $date_updated_end = null, $date_updated_start = null, $include = null, $multi_unit = null, $property_id = null, $property_rating_max = null, $property_rating_min = null, $billing_terms = null, $partner_point_of_sale = null, $payment_terms = null, $platform_name = null, string $contentType = self::contentTypes['getPropertyContent'][0])
    {
        return $this->getPropertyContentAsyncWithHttpInfo($accept, $accept_encoding, $user_agent, $language, $supply_source, $customer_session_id, $brand_id, $business_model, $category_id_exclude, $chain_id, $country_code, $date_added_end, $date_added_start, $date_updated_end, $date_updated_start, $include, $multi_unit, $property_id, $property_rating_max, $property_rating_min, $billing_terms, $partner_point_of_sale, $payment_terms, $platform_name, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getPropertyContentAsyncWithHttpInfo
     *
     * Property Content
     *
     * @param  string $accept Specifies the response format that the client would like to receive back. This must be &#x60;application/json&#x60;. (required)
     * @param  string $accept_encoding Specifies the response encoding that the client would like to receive back. This must be &#x60;gzip&#x60;. (required)
     * @param  string $user_agent The &#x60;User-Agent&#x60; header string from the customer&#39;s request, as captured by your integration. If you are building an application then the &#x60;User-Agent&#x60; value should be &#x60;{app name}/{app version}&#x60;. (required)
     * @param  string $language Desired language for the response as a subset of BCP47 format that only uses hyphenated pairs of two-digit language and country codes. Use only ISO 639-1 alpha-2 language codes and ISO 3166-1 alpha-2 country codes. See [https://www.w3.org/International/articles/language-tags/](https://www.w3.org/International/articles/language-tags/)  Language Options: [https://developers.expediagroup.com/docs/rapid/resources/reference/language-options](https://developers.expediagroup.com/docs/rapid/resources/reference/language-options) (required)
     * @param  string $supply_source Options for which supply source you would like returned in the content response. This parameter may only be supplied once and will return all properties that match the requested supply source. An error is thrown if the parameter is provided multiple times.   * &#x60;expedia&#x60; - Standard Expedia supply.   * &#x60;vrbo&#x60; - VRBO supply - This option is restricted to partners who have VRBO supply enabled for their profile. See [Vacation Rentals](https://developers.expediagroup.com/docs/rapid/lodging/vacation-rentals) for more information. (required)
     * @param  string $customer_session_id Insert your own unique value for each user session, beginning with the first API call. Continue to pass the same value for each subsequent API call during the user&#39;s session, using a new value for every new customer session.&lt;br&gt; Including this value greatly eases EPS&#39;s internal debugging process for issues with partner requests, as it explicitly links together request paths for individual user&#39;s session. (optional)
     * @param  string[] $brand_id The ID of the brand you want to search for. This parameter can be supplied multiple times with different values, which will include properties that match any of the requested brand IDs. (optional)
     * @param  string[] $business_model Search for properties with the requested business model enabled. This parameter can be supplied multiple times with different values, which will return all properties that match any of the requested business models. The value must be lower case.  Possible values:   * expedia_collect - Return only properties where the payment is collected by Expedia.   * property_collect - Return only properties where the payment is collected at the property. (optional)
     * @param  string[] $category_id_exclude Search to exclude properties that do not have the requested [category ID](https://developers.expediagroup.com/docs/rapid/lodging/content/content-reference-lists). If this parameter is not supplied, all category IDs are included. This parameter can be supplied multiple times with different values, which will exclude properties that match any of the requested category IDs. (optional)
     * @param  string[] $chain_id The ID of the chain you want to search for. These chain IDs can be positive and negative numbers. This parameter can be supplied multiple times with different values, which will include properties that match any of the requested chain IDs. (optional)
     * @param  string[] $country_code Search for properties with the requested country code, in ISO 3166-1 alpha-2 format. This parameter can be supplied multiple times with different values, which will include properties that match any of the requested country codes. (optional)
     * @param  string $date_added_end Search for properties added on or before the requested UTC date, in ISO 8601 format (YYYY-MM-DD) (optional)
     * @param  string $date_added_start Search for properties added on or after the requested UTC date, in ISO 8601 format (YYYY-MM-DD) (optional)
     * @param  string $date_updated_end Search for properties updated on or before the requested UTC date, in ISO 8601 format (YYYY-MM-DD) (optional)
     * @param  string $date_updated_start Search for properties updated on or after the requested UTC date, in ISO 8601 format (YYYY-MM-DD) (optional)
     * @param  string[] $include Option for limiting what fields to return in the response. The value must be lower case. This parameter can be supplied multiple times with different values, which will return a combination of all fields asked for.  Possible values:  * property_ids - Return only the property id of the property object.  * catalog - Return only the property catalog property-level fields.  * address - Returns only the address fields. (optional)
     * @param  bool $multi_unit Search for multi-unit properties. If this parameter is not supplied, both single-unit and multi-unit properties will be included.  Possible values:   * true - Include only properties that are multi-unit.   * false - Do not include properties that are multi-unit. (optional)
     * @param  string[] $property_id The ID of the property you want to search for. You can provide 1 to 250 property_id parameters. (optional)
     * @param  string $property_rating_max Search for properties with a property rating less than or equal to the requested rating. The highest property rating value is 5.0. (optional)
     * @param  string $property_rating_min Search for properties with a property rating greater than or equal to the requested rating. The lowest property rating value is 0.0. (optional)
     * @param  string $billing_terms This parameter is to specify the terms of how a resulting booking should be billed. If this field is needed, the value for this will be provided to you separately. (optional)
     * @param  string $partner_point_of_sale This parameter is to specify what point of sale is being used to shop and book. If this field is needed, the value for this will be provided to you separately. (optional)
     * @param  string $payment_terms This parameter is to specify what terms should be used when being paid for a resulting booking. If this field is needed, the value for this will be provided to you separately. (optional)
     * @param  string $platform_name This parameter is to specify what platform is being used to shop and book. If this field is needed, the value for this will be provided to you separately. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getPropertyContent'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getPropertyContentAsyncWithHttpInfo($accept, $accept_encoding, $user_agent, $language, $supply_source, $customer_session_id = null, $brand_id = null, $business_model = null, $category_id_exclude = null, $chain_id = null, $country_code = null, $date_added_end = null, $date_added_start = null, $date_updated_end = null, $date_updated_start = null, $include = null, $multi_unit = null, $property_id = null, $property_rating_max = null, $property_rating_min = null, $billing_terms = null, $partner_point_of_sale = null, $payment_terms = null, $platform_name = null, string $contentType = self::contentTypes['getPropertyContent'][0])
    {
        $returnType = 'array<string,\OpenAPI\Client\Model\PropertyContent>';
        $request = $this->getPropertyContentRequest($accept, $accept_encoding, $user_agent, $language, $supply_source, $customer_session_id, $brand_id, $business_model, $category_id_exclude, $chain_id, $country_code, $date_added_end, $date_added_start, $date_updated_end, $date_updated_start, $include, $multi_unit, $property_id, $property_rating_max, $property_rating_min, $billing_terms, $partner_point_of_sale, $payment_terms, $platform_name, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getPropertyContent'
     *
     * @param  string $accept Specifies the response format that the client would like to receive back. This must be &#x60;application/json&#x60;. (required)
     * @param  string $accept_encoding Specifies the response encoding that the client would like to receive back. This must be &#x60;gzip&#x60;. (required)
     * @param  string $user_agent The &#x60;User-Agent&#x60; header string from the customer&#39;s request, as captured by your integration. If you are building an application then the &#x60;User-Agent&#x60; value should be &#x60;{app name}/{app version}&#x60;. (required)
     * @param  string $language Desired language for the response as a subset of BCP47 format that only uses hyphenated pairs of two-digit language and country codes. Use only ISO 639-1 alpha-2 language codes and ISO 3166-1 alpha-2 country codes. See [https://www.w3.org/International/articles/language-tags/](https://www.w3.org/International/articles/language-tags/)  Language Options: [https://developers.expediagroup.com/docs/rapid/resources/reference/language-options](https://developers.expediagroup.com/docs/rapid/resources/reference/language-options) (required)
     * @param  string $supply_source Options for which supply source you would like returned in the content response. This parameter may only be supplied once and will return all properties that match the requested supply source. An error is thrown if the parameter is provided multiple times.   * &#x60;expedia&#x60; - Standard Expedia supply.   * &#x60;vrbo&#x60; - VRBO supply - This option is restricted to partners who have VRBO supply enabled for their profile. See [Vacation Rentals](https://developers.expediagroup.com/docs/rapid/lodging/vacation-rentals) for more information. (required)
     * @param  string $customer_session_id Insert your own unique value for each user session, beginning with the first API call. Continue to pass the same value for each subsequent API call during the user&#39;s session, using a new value for every new customer session.&lt;br&gt; Including this value greatly eases EPS&#39;s internal debugging process for issues with partner requests, as it explicitly links together request paths for individual user&#39;s session. (optional)
     * @param  string[] $brand_id The ID of the brand you want to search for. This parameter can be supplied multiple times with different values, which will include properties that match any of the requested brand IDs. (optional)
     * @param  string[] $business_model Search for properties with the requested business model enabled. This parameter can be supplied multiple times with different values, which will return all properties that match any of the requested business models. The value must be lower case.  Possible values:   * expedia_collect - Return only properties where the payment is collected by Expedia.   * property_collect - Return only properties where the payment is collected at the property. (optional)
     * @param  string[] $category_id_exclude Search to exclude properties that do not have the requested [category ID](https://developers.expediagroup.com/docs/rapid/lodging/content/content-reference-lists). If this parameter is not supplied, all category IDs are included. This parameter can be supplied multiple times with different values, which will exclude properties that match any of the requested category IDs. (optional)
     * @param  string[] $chain_id The ID of the chain you want to search for. These chain IDs can be positive and negative numbers. This parameter can be supplied multiple times with different values, which will include properties that match any of the requested chain IDs. (optional)
     * @param  string[] $country_code Search for properties with the requested country code, in ISO 3166-1 alpha-2 format. This parameter can be supplied multiple times with different values, which will include properties that match any of the requested country codes. (optional)
     * @param  string $date_added_end Search for properties added on or before the requested UTC date, in ISO 8601 format (YYYY-MM-DD) (optional)
     * @param  string $date_added_start Search for properties added on or after the requested UTC date, in ISO 8601 format (YYYY-MM-DD) (optional)
     * @param  string $date_updated_end Search for properties updated on or before the requested UTC date, in ISO 8601 format (YYYY-MM-DD) (optional)
     * @param  string $date_updated_start Search for properties updated on or after the requested UTC date, in ISO 8601 format (YYYY-MM-DD) (optional)
     * @param  string[] $include Option for limiting what fields to return in the response. The value must be lower case. This parameter can be supplied multiple times with different values, which will return a combination of all fields asked for.  Possible values:  * property_ids - Return only the property id of the property object.  * catalog - Return only the property catalog property-level fields.  * address - Returns only the address fields. (optional)
     * @param  bool $multi_unit Search for multi-unit properties. If this parameter is not supplied, both single-unit and multi-unit properties will be included.  Possible values:   * true - Include only properties that are multi-unit.   * false - Do not include properties that are multi-unit. (optional)
     * @param  string[] $property_id The ID of the property you want to search for. You can provide 1 to 250 property_id parameters. (optional)
     * @param  string $property_rating_max Search for properties with a property rating less than or equal to the requested rating. The highest property rating value is 5.0. (optional)
     * @param  string $property_rating_min Search for properties with a property rating greater than or equal to the requested rating. The lowest property rating value is 0.0. (optional)
     * @param  string $billing_terms This parameter is to specify the terms of how a resulting booking should be billed. If this field is needed, the value for this will be provided to you separately. (optional)
     * @param  string $partner_point_of_sale This parameter is to specify what point of sale is being used to shop and book. If this field is needed, the value for this will be provided to you separately. (optional)
     * @param  string $payment_terms This parameter is to specify what terms should be used when being paid for a resulting booking. If this field is needed, the value for this will be provided to you separately. (optional)
     * @param  string $platform_name This parameter is to specify what platform is being used to shop and book. If this field is needed, the value for this will be provided to you separately. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getPropertyContent'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function getPropertyContentRequest($accept, $accept_encoding, $user_agent, $language, $supply_source, $customer_session_id = null, $brand_id = null, $business_model = null, $category_id_exclude = null, $chain_id = null, $country_code = null, $date_added_end = null, $date_added_start = null, $date_updated_end = null, $date_updated_start = null, $include = null, $multi_unit = null, $property_id = null, $property_rating_max = null, $property_rating_min = null, $billing_terms = null, $partner_point_of_sale = null, $payment_terms = null, $platform_name = null, string $contentType = self::contentTypes['getPropertyContent'][0])
    {

        // verify the required parameter 'accept' is set
        if ($accept === null || (is_array($accept) && count($accept) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $accept when calling getPropertyContent'
            );
        }

        // verify the required parameter 'accept_encoding' is set
        if ($accept_encoding === null || (is_array($accept_encoding) && count($accept_encoding) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $accept_encoding when calling getPropertyContent'
            );
        }

        // verify the required parameter 'user_agent' is set
        if ($user_agent === null || (is_array($user_agent) && count($user_agent) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $user_agent when calling getPropertyContent'
            );
        }

        // verify the required parameter 'language' is set
        if ($language === null || (is_array($language) && count($language) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $language when calling getPropertyContent'
            );
        }

        // verify the required parameter 'supply_source' is set
        if ($supply_source === null || (is_array($supply_source) && count($supply_source) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $supply_source when calling getPropertyContent'
            );
        }





















        $resourcePath = '/properties/content';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $language,
            'language', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            true // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $brand_id,
            'brand_id', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $business_model,
            'business_model', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $category_id_exclude,
            'category_id_exclude', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $chain_id,
            'chain_id', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $country_code,
            'country_code', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $date_added_end,
            'date_added_end', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $date_added_start,
            'date_added_start', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $date_updated_end,
            'date_updated_end', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $date_updated_start,
            'date_updated_start', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $include,
            'include', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $multi_unit,
            'multi_unit', // param base name
            'boolean', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $property_id,
            'property_id', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $property_rating_max,
            'property_rating_max', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $property_rating_min,
            'property_rating_min', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $supply_source,
            'supply_source', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            true // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $billing_terms,
            'billing_terms', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $partner_point_of_sale,
            'partner_point_of_sale', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $payment_terms,
            'payment_terms', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $platform_name,
            'platform_name', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);

        // header params
        if ($accept !== null) {
            $headerParams['Accept'] = ObjectSerializer::toHeaderValue($accept);
        }
        // header params
        if ($accept_encoding !== null) {
            $headerParams['Accept-Encoding'] = ObjectSerializer::toHeaderValue($accept_encoding);
        }
        // header params
        if ($user_agent !== null) {
            $headerParams['User-Agent'] = ObjectSerializer::toHeaderValue($user_agent);
        }
        // header params
        if ($customer_session_id !== null) {
            $headerParams['Customer-Session-Id'] = ObjectSerializer::toHeaderValue($customer_session_id);
        }



        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getPropertyContentFile
     *
     * Property Content File
     *
     * @param  string $accept Specifies the response format that the client would like to receive back. This must be &#x60;application/json&#x60;. (required)
     * @param  string $accept_encoding Specifies the response encoding that the client would like to receive back. This must be &#x60;gzip&#x60;. (required)
     * @param  string $user_agent The &#x60;User-Agent&#x60; header string from the customer&#39;s request, as captured by your integration. If you are building an application then the &#x60;User-Agent&#x60; value should be &#x60;{app name}/{app version}&#x60;. (required)
     * @param  string $language Desired language for the response as a subset of BCP47 format that only uses hyphenated pairs of two-digit language and country codes. Use only ISO 639-1 alpha-2 language codes and ISO 3166-1 alpha-2 country codes. See [https://www.w3.org/International/articles/language-tags/](https://www.w3.org/International/articles/language-tags/)  Language Options: [https://developers.expediagroup.com/docs/rapid/resources/reference/language-options](https://developers.expediagroup.com/docs/rapid/resources/reference/language-options) (required)
     * @param  string $supply_source Options for which supply source you would like returned in the content response. This parameter may only be supplied once and will return all properties that match the requested supply source. An error is thrown if the parameter is provided multiple times.   * &#x60;expedia&#x60; - Standard Expedia supply.   * &#x60;vrbo&#x60; - VRBO supply - This option is restricted to partners who have VRBO supply enabled for their profile. See [Vacation Rentals](https://developers.expediagroup.com/docs/rapid/lodging/vacation-rentals) for more information. (required)
     * @param  string $customer_session_id Insert your own unique value for each user session, beginning with the first API call. Continue to pass the same value for each subsequent API call during the user&#39;s session, using a new value for every new customer session.&lt;br&gt; Including this value greatly eases EPS&#39;s internal debugging process for issues with partner requests, as it explicitly links together request paths for individual user&#39;s session. (optional)
     * @param  string $billing_terms This parameter is to specify the terms of how a resulting booking should be billed. If this field is needed, the value for this will be provided to you separately. (optional)
     * @param  string $payment_terms This parameter is to specify what terms should be used when being paid for a resulting booking. If this field is needed, the value for this will be provided to you separately. (optional)
     * @param  string $partner_point_of_sale This parameter is to specify what point of sale is being used to shop and book. If this field is needed, the value for this will be provided to you separately. (optional)
     * @param  string $platform_name This parameter is to specify what platform is being used to shop and book. If this field is needed, the value for this will be provided to you separately. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getPropertyContentFile'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\Link|\OpenAPI\Client\Model\Error|\OpenAPI\Client\Model\Error|\OpenAPI\Client\Model\Error|\OpenAPI\Client\Model\Error|\OpenAPI\Client\Model\Error|\OpenAPI\Client\Model\Error|\OpenAPI\Client\Model\Error|\OpenAPI\Client\Model\Error
     */
    public function getPropertyContentFile($accept, $accept_encoding, $user_agent, $language, $supply_source, $customer_session_id = null, $billing_terms = null, $payment_terms = null, $partner_point_of_sale = null, $platform_name = null, string $contentType = self::contentTypes['getPropertyContentFile'][0])
    {
        list($response) = $this->getPropertyContentFileWithHttpInfo($accept, $accept_encoding, $user_agent, $language, $supply_source, $customer_session_id, $billing_terms, $payment_terms, $partner_point_of_sale, $platform_name, $contentType);
        return $response;
    }

    /**
     * Operation getPropertyContentFileWithHttpInfo
     *
     * Property Content File
     *
     * @param  string $accept Specifies the response format that the client would like to receive back. This must be &#x60;application/json&#x60;. (required)
     * @param  string $accept_encoding Specifies the response encoding that the client would like to receive back. This must be &#x60;gzip&#x60;. (required)
     * @param  string $user_agent The &#x60;User-Agent&#x60; header string from the customer&#39;s request, as captured by your integration. If you are building an application then the &#x60;User-Agent&#x60; value should be &#x60;{app name}/{app version}&#x60;. (required)
     * @param  string $language Desired language for the response as a subset of BCP47 format that only uses hyphenated pairs of two-digit language and country codes. Use only ISO 639-1 alpha-2 language codes and ISO 3166-1 alpha-2 country codes. See [https://www.w3.org/International/articles/language-tags/](https://www.w3.org/International/articles/language-tags/)  Language Options: [https://developers.expediagroup.com/docs/rapid/resources/reference/language-options](https://developers.expediagroup.com/docs/rapid/resources/reference/language-options) (required)
     * @param  string $supply_source Options for which supply source you would like returned in the content response. This parameter may only be supplied once and will return all properties that match the requested supply source. An error is thrown if the parameter is provided multiple times.   * &#x60;expedia&#x60; - Standard Expedia supply.   * &#x60;vrbo&#x60; - VRBO supply - This option is restricted to partners who have VRBO supply enabled for their profile. See [Vacation Rentals](https://developers.expediagroup.com/docs/rapid/lodging/vacation-rentals) for more information. (required)
     * @param  string $customer_session_id Insert your own unique value for each user session, beginning with the first API call. Continue to pass the same value for each subsequent API call during the user&#39;s session, using a new value for every new customer session.&lt;br&gt; Including this value greatly eases EPS&#39;s internal debugging process for issues with partner requests, as it explicitly links together request paths for individual user&#39;s session. (optional)
     * @param  string $billing_terms This parameter is to specify the terms of how a resulting booking should be billed. If this field is needed, the value for this will be provided to you separately. (optional)
     * @param  string $payment_terms This parameter is to specify what terms should be used when being paid for a resulting booking. If this field is needed, the value for this will be provided to you separately. (optional)
     * @param  string $partner_point_of_sale This parameter is to specify what point of sale is being used to shop and book. If this field is needed, the value for this will be provided to you separately. (optional)
     * @param  string $platform_name This parameter is to specify what platform is being used to shop and book. If this field is needed, the value for this will be provided to you separately. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getPropertyContentFile'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\Link|\OpenAPI\Client\Model\Error|\OpenAPI\Client\Model\Error|\OpenAPI\Client\Model\Error|\OpenAPI\Client\Model\Error|\OpenAPI\Client\Model\Error|\OpenAPI\Client\Model\Error|\OpenAPI\Client\Model\Error|\OpenAPI\Client\Model\Error, HTTP status code, HTTP response headers (array of strings)
     */
    public function getPropertyContentFileWithHttpInfo($accept, $accept_encoding, $user_agent, $language, $supply_source, $customer_session_id = null, $billing_terms = null, $payment_terms = null, $partner_point_of_sale = null, $platform_name = null, string $contentType = self::contentTypes['getPropertyContentFile'][0])
    {
        $request = $this->getPropertyContentFileRequest($accept, $accept_encoding, $user_agent, $language, $supply_source, $customer_session_id, $billing_terms, $payment_terms, $partner_point_of_sale, $platform_name, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\Link' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\Link' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\Link', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 400:
                    if ('\OpenAPI\Client\Model\Error' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\Error' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\Error', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 401:
                    if ('\OpenAPI\Client\Model\Error' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\Error' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\Error', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 403:
                    if ('\OpenAPI\Client\Model\Error' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\Error' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\Error', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 404:
                    if ('\OpenAPI\Client\Model\Error' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\Error' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\Error', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 426:
                    if ('\OpenAPI\Client\Model\Error' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\Error' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\Error', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 429:
                    if ('\OpenAPI\Client\Model\Error' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\Error' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\Error', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 500:
                    if ('\OpenAPI\Client\Model\Error' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\Error' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\Error', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 503:
                    if ('\OpenAPI\Client\Model\Error' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\Error' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\Error', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\Link';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\Link',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\Error',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 401:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\Error',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 403:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\Error',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 404:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\Error',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 426:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\Error',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 429:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\Error',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 500:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\Error',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 503:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\Error',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getPropertyContentFileAsync
     *
     * Property Content File
     *
     * @param  string $accept Specifies the response format that the client would like to receive back. This must be &#x60;application/json&#x60;. (required)
     * @param  string $accept_encoding Specifies the response encoding that the client would like to receive back. This must be &#x60;gzip&#x60;. (required)
     * @param  string $user_agent The &#x60;User-Agent&#x60; header string from the customer&#39;s request, as captured by your integration. If you are building an application then the &#x60;User-Agent&#x60; value should be &#x60;{app name}/{app version}&#x60;. (required)
     * @param  string $language Desired language for the response as a subset of BCP47 format that only uses hyphenated pairs of two-digit language and country codes. Use only ISO 639-1 alpha-2 language codes and ISO 3166-1 alpha-2 country codes. See [https://www.w3.org/International/articles/language-tags/](https://www.w3.org/International/articles/language-tags/)  Language Options: [https://developers.expediagroup.com/docs/rapid/resources/reference/language-options](https://developers.expediagroup.com/docs/rapid/resources/reference/language-options) (required)
     * @param  string $supply_source Options for which supply source you would like returned in the content response. This parameter may only be supplied once and will return all properties that match the requested supply source. An error is thrown if the parameter is provided multiple times.   * &#x60;expedia&#x60; - Standard Expedia supply.   * &#x60;vrbo&#x60; - VRBO supply - This option is restricted to partners who have VRBO supply enabled for their profile. See [Vacation Rentals](https://developers.expediagroup.com/docs/rapid/lodging/vacation-rentals) for more information. (required)
     * @param  string $customer_session_id Insert your own unique value for each user session, beginning with the first API call. Continue to pass the same value for each subsequent API call during the user&#39;s session, using a new value for every new customer session.&lt;br&gt; Including this value greatly eases EPS&#39;s internal debugging process for issues with partner requests, as it explicitly links together request paths for individual user&#39;s session. (optional)
     * @param  string $billing_terms This parameter is to specify the terms of how a resulting booking should be billed. If this field is needed, the value for this will be provided to you separately. (optional)
     * @param  string $payment_terms This parameter is to specify what terms should be used when being paid for a resulting booking. If this field is needed, the value for this will be provided to you separately. (optional)
     * @param  string $partner_point_of_sale This parameter is to specify what point of sale is being used to shop and book. If this field is needed, the value for this will be provided to you separately. (optional)
     * @param  string $platform_name This parameter is to specify what platform is being used to shop and book. If this field is needed, the value for this will be provided to you separately. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getPropertyContentFile'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getPropertyContentFileAsync($accept, $accept_encoding, $user_agent, $language, $supply_source, $customer_session_id = null, $billing_terms = null, $payment_terms = null, $partner_point_of_sale = null, $platform_name = null, string $contentType = self::contentTypes['getPropertyContentFile'][0])
    {
        return $this->getPropertyContentFileAsyncWithHttpInfo($accept, $accept_encoding, $user_agent, $language, $supply_source, $customer_session_id, $billing_terms, $payment_terms, $partner_point_of_sale, $platform_name, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getPropertyContentFileAsyncWithHttpInfo
     *
     * Property Content File
     *
     * @param  string $accept Specifies the response format that the client would like to receive back. This must be &#x60;application/json&#x60;. (required)
     * @param  string $accept_encoding Specifies the response encoding that the client would like to receive back. This must be &#x60;gzip&#x60;. (required)
     * @param  string $user_agent The &#x60;User-Agent&#x60; header string from the customer&#39;s request, as captured by your integration. If you are building an application then the &#x60;User-Agent&#x60; value should be &#x60;{app name}/{app version}&#x60;. (required)
     * @param  string $language Desired language for the response as a subset of BCP47 format that only uses hyphenated pairs of two-digit language and country codes. Use only ISO 639-1 alpha-2 language codes and ISO 3166-1 alpha-2 country codes. See [https://www.w3.org/International/articles/language-tags/](https://www.w3.org/International/articles/language-tags/)  Language Options: [https://developers.expediagroup.com/docs/rapid/resources/reference/language-options](https://developers.expediagroup.com/docs/rapid/resources/reference/language-options) (required)
     * @param  string $supply_source Options for which supply source you would like returned in the content response. This parameter may only be supplied once and will return all properties that match the requested supply source. An error is thrown if the parameter is provided multiple times.   * &#x60;expedia&#x60; - Standard Expedia supply.   * &#x60;vrbo&#x60; - VRBO supply - This option is restricted to partners who have VRBO supply enabled for their profile. See [Vacation Rentals](https://developers.expediagroup.com/docs/rapid/lodging/vacation-rentals) for more information. (required)
     * @param  string $customer_session_id Insert your own unique value for each user session, beginning with the first API call. Continue to pass the same value for each subsequent API call during the user&#39;s session, using a new value for every new customer session.&lt;br&gt; Including this value greatly eases EPS&#39;s internal debugging process for issues with partner requests, as it explicitly links together request paths for individual user&#39;s session. (optional)
     * @param  string $billing_terms This parameter is to specify the terms of how a resulting booking should be billed. If this field is needed, the value for this will be provided to you separately. (optional)
     * @param  string $payment_terms This parameter is to specify what terms should be used when being paid for a resulting booking. If this field is needed, the value for this will be provided to you separately. (optional)
     * @param  string $partner_point_of_sale This parameter is to specify what point of sale is being used to shop and book. If this field is needed, the value for this will be provided to you separately. (optional)
     * @param  string $platform_name This parameter is to specify what platform is being used to shop and book. If this field is needed, the value for this will be provided to you separately. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getPropertyContentFile'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getPropertyContentFileAsyncWithHttpInfo($accept, $accept_encoding, $user_agent, $language, $supply_source, $customer_session_id = null, $billing_terms = null, $payment_terms = null, $partner_point_of_sale = null, $platform_name = null, string $contentType = self::contentTypes['getPropertyContentFile'][0])
    {
        $returnType = '\OpenAPI\Client\Model\Link';
        $request = $this->getPropertyContentFileRequest($accept, $accept_encoding, $user_agent, $language, $supply_source, $customer_session_id, $billing_terms, $payment_terms, $partner_point_of_sale, $platform_name, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getPropertyContentFile'
     *
     * @param  string $accept Specifies the response format that the client would like to receive back. This must be &#x60;application/json&#x60;. (required)
     * @param  string $accept_encoding Specifies the response encoding that the client would like to receive back. This must be &#x60;gzip&#x60;. (required)
     * @param  string $user_agent The &#x60;User-Agent&#x60; header string from the customer&#39;s request, as captured by your integration. If you are building an application then the &#x60;User-Agent&#x60; value should be &#x60;{app name}/{app version}&#x60;. (required)
     * @param  string $language Desired language for the response as a subset of BCP47 format that only uses hyphenated pairs of two-digit language and country codes. Use only ISO 639-1 alpha-2 language codes and ISO 3166-1 alpha-2 country codes. See [https://www.w3.org/International/articles/language-tags/](https://www.w3.org/International/articles/language-tags/)  Language Options: [https://developers.expediagroup.com/docs/rapid/resources/reference/language-options](https://developers.expediagroup.com/docs/rapid/resources/reference/language-options) (required)
     * @param  string $supply_source Options for which supply source you would like returned in the content response. This parameter may only be supplied once and will return all properties that match the requested supply source. An error is thrown if the parameter is provided multiple times.   * &#x60;expedia&#x60; - Standard Expedia supply.   * &#x60;vrbo&#x60; - VRBO supply - This option is restricted to partners who have VRBO supply enabled for their profile. See [Vacation Rentals](https://developers.expediagroup.com/docs/rapid/lodging/vacation-rentals) for more information. (required)
     * @param  string $customer_session_id Insert your own unique value for each user session, beginning with the first API call. Continue to pass the same value for each subsequent API call during the user&#39;s session, using a new value for every new customer session.&lt;br&gt; Including this value greatly eases EPS&#39;s internal debugging process for issues with partner requests, as it explicitly links together request paths for individual user&#39;s session. (optional)
     * @param  string $billing_terms This parameter is to specify the terms of how a resulting booking should be billed. If this field is needed, the value for this will be provided to you separately. (optional)
     * @param  string $payment_terms This parameter is to specify what terms should be used when being paid for a resulting booking. If this field is needed, the value for this will be provided to you separately. (optional)
     * @param  string $partner_point_of_sale This parameter is to specify what point of sale is being used to shop and book. If this field is needed, the value for this will be provided to you separately. (optional)
     * @param  string $platform_name This parameter is to specify what platform is being used to shop and book. If this field is needed, the value for this will be provided to you separately. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getPropertyContentFile'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function getPropertyContentFileRequest($accept, $accept_encoding, $user_agent, $language, $supply_source, $customer_session_id = null, $billing_terms = null, $payment_terms = null, $partner_point_of_sale = null, $platform_name = null, string $contentType = self::contentTypes['getPropertyContentFile'][0])
    {

        // verify the required parameter 'accept' is set
        if ($accept === null || (is_array($accept) && count($accept) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $accept when calling getPropertyContentFile'
            );
        }

        // verify the required parameter 'accept_encoding' is set
        if ($accept_encoding === null || (is_array($accept_encoding) && count($accept_encoding) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $accept_encoding when calling getPropertyContentFile'
            );
        }

        // verify the required parameter 'user_agent' is set
        if ($user_agent === null || (is_array($user_agent) && count($user_agent) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $user_agent when calling getPropertyContentFile'
            );
        }

        // verify the required parameter 'language' is set
        if ($language === null || (is_array($language) && count($language) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $language when calling getPropertyContentFile'
            );
        }

        // verify the required parameter 'supply_source' is set
        if ($supply_source === null || (is_array($supply_source) && count($supply_source) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $supply_source when calling getPropertyContentFile'
            );
        }







        $resourcePath = '/files/properties/content';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $language,
            'language', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            true // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $supply_source,
            'supply_source', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            true // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $billing_terms,
            'billing_terms', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $payment_terms,
            'payment_terms', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $partner_point_of_sale,
            'partner_point_of_sale', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $platform_name,
            'platform_name', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);

        // header params
        if ($accept !== null) {
            $headerParams['Accept'] = ObjectSerializer::toHeaderValue($accept);
        }
        // header params
        if ($accept_encoding !== null) {
            $headerParams['Accept-Encoding'] = ObjectSerializer::toHeaderValue($accept_encoding);
        }
        // header params
        if ($customer_session_id !== null) {
            $headerParams['Customer-Session-Id'] = ObjectSerializer::toHeaderValue($customer_session_id);
        }
        // header params
        if ($user_agent !== null) {
            $headerParams['User-Agent'] = ObjectSerializer::toHeaderValue($user_agent);
        }



        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getPropertyGuestReviews
     *
     * Property Guest Reviews
     *
     * @param  string $accept Specifies the response format that the client would like to receive back. This must be &#x60;application/json&#x60;. (required)
     * @param  string $accept_encoding Specifies the response encoding that the client would like to receive back. This must be &#x60;gzip&#x60;. (required)
     * @param  string $user_agent The &#x60;User-Agent&#x60; header string from the customer&#39;s request, as captured by your integration. If you are building an application then the &#x60;User-Agent&#x60; value should be &#x60;{app name}/{app version}&#x60;. (required)
     * @param  string $property_id Expedia Property ID.&lt;br&gt; (required)
     * @param  string $language Desired language for the response as a subset of BCP47 format that only uses hyphenated pairs of two-digit language and country codes. Use only ISO 639-1 alpha-2 language codes and ISO 3166-1 alpha-2 country codes. See [https://www.w3.org/International/articles/language-tags/](https://www.w3.org/International/articles/language-tags/)  Language Options: [https://developers.expediagroup.com/docs/rapid/resources/reference/language-options](https://developers.expediagroup.com/docs/rapid/resources/reference/language-options) (required)
     * @param  string $customer_session_id Insert your own unique value for each user session, beginning with the first API call. Continue to pass the same value for each subsequent API call during the user&#39;s session, using a new value for every new customer session.&lt;br&gt; Including this value greatly eases EPS&#39;s internal debugging process for issues with partner requests, as it explicitly links together request paths for individual user&#39;s session. (optional)
     * @param  string $billing_terms This parameter is to specify the terms of how a resulting booking should be billed. If this field is needed, the value for this will be provided to you separately. (optional)
     * @param  string $payment_terms This parameter is to specify what terms should be used when being paid for a resulting booking. If this field is needed, the value for this will be provided to you separately. (optional)
     * @param  string $partner_point_of_sale This parameter is to specify what point of sale is being used to shop and book. If this field is needed, the value for this will be provided to you separately. (optional)
     * @param  string $platform_name This parameter is to specify what platform is being used to shop and book. If this field is needed, the value for this will be provided to you separately. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getPropertyGuestReviews'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\GuestReviews|\OpenAPI\Client\Model\Error|\OpenAPI\Client\Model\Error|\OpenAPI\Client\Model\Error|\OpenAPI\Client\Model\Error|\OpenAPI\Client\Model\Error|\OpenAPI\Client\Model\Error|\OpenAPI\Client\Model\Error|\OpenAPI\Client\Model\Error
     */
    public function getPropertyGuestReviews($accept, $accept_encoding, $user_agent, $property_id, $language, $customer_session_id = null, $billing_terms = null, $payment_terms = null, $partner_point_of_sale = null, $platform_name = null, string $contentType = self::contentTypes['getPropertyGuestReviews'][0])
    {
        list($response) = $this->getPropertyGuestReviewsWithHttpInfo($accept, $accept_encoding, $user_agent, $property_id, $language, $customer_session_id, $billing_terms, $payment_terms, $partner_point_of_sale, $platform_name, $contentType);
        return $response;
    }

    /**
     * Operation getPropertyGuestReviewsWithHttpInfo
     *
     * Property Guest Reviews
     *
     * @param  string $accept Specifies the response format that the client would like to receive back. This must be &#x60;application/json&#x60;. (required)
     * @param  string $accept_encoding Specifies the response encoding that the client would like to receive back. This must be &#x60;gzip&#x60;. (required)
     * @param  string $user_agent The &#x60;User-Agent&#x60; header string from the customer&#39;s request, as captured by your integration. If you are building an application then the &#x60;User-Agent&#x60; value should be &#x60;{app name}/{app version}&#x60;. (required)
     * @param  string $property_id Expedia Property ID.&lt;br&gt; (required)
     * @param  string $language Desired language for the response as a subset of BCP47 format that only uses hyphenated pairs of two-digit language and country codes. Use only ISO 639-1 alpha-2 language codes and ISO 3166-1 alpha-2 country codes. See [https://www.w3.org/International/articles/language-tags/](https://www.w3.org/International/articles/language-tags/)  Language Options: [https://developers.expediagroup.com/docs/rapid/resources/reference/language-options](https://developers.expediagroup.com/docs/rapid/resources/reference/language-options) (required)
     * @param  string $customer_session_id Insert your own unique value for each user session, beginning with the first API call. Continue to pass the same value for each subsequent API call during the user&#39;s session, using a new value for every new customer session.&lt;br&gt; Including this value greatly eases EPS&#39;s internal debugging process for issues with partner requests, as it explicitly links together request paths for individual user&#39;s session. (optional)
     * @param  string $billing_terms This parameter is to specify the terms of how a resulting booking should be billed. If this field is needed, the value for this will be provided to you separately. (optional)
     * @param  string $payment_terms This parameter is to specify what terms should be used when being paid for a resulting booking. If this field is needed, the value for this will be provided to you separately. (optional)
     * @param  string $partner_point_of_sale This parameter is to specify what point of sale is being used to shop and book. If this field is needed, the value for this will be provided to you separately. (optional)
     * @param  string $platform_name This parameter is to specify what platform is being used to shop and book. If this field is needed, the value for this will be provided to you separately. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getPropertyGuestReviews'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\GuestReviews|\OpenAPI\Client\Model\Error|\OpenAPI\Client\Model\Error|\OpenAPI\Client\Model\Error|\OpenAPI\Client\Model\Error|\OpenAPI\Client\Model\Error|\OpenAPI\Client\Model\Error|\OpenAPI\Client\Model\Error|\OpenAPI\Client\Model\Error, HTTP status code, HTTP response headers (array of strings)
     */
    public function getPropertyGuestReviewsWithHttpInfo($accept, $accept_encoding, $user_agent, $property_id, $language, $customer_session_id = null, $billing_terms = null, $payment_terms = null, $partner_point_of_sale = null, $platform_name = null, string $contentType = self::contentTypes['getPropertyGuestReviews'][0])
    {
        $request = $this->getPropertyGuestReviewsRequest($accept, $accept_encoding, $user_agent, $property_id, $language, $customer_session_id, $billing_terms, $payment_terms, $partner_point_of_sale, $platform_name, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\GuestReviews' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\GuestReviews' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\GuestReviews', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 400:
                    if ('\OpenAPI\Client\Model\Error' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\Error' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\Error', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 401:
                    if ('\OpenAPI\Client\Model\Error' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\Error' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\Error', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 403:
                    if ('\OpenAPI\Client\Model\Error' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\Error' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\Error', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 404:
                    if ('\OpenAPI\Client\Model\Error' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\Error' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\Error', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 426:
                    if ('\OpenAPI\Client\Model\Error' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\Error' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\Error', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 429:
                    if ('\OpenAPI\Client\Model\Error' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\Error' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\Error', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 500:
                    if ('\OpenAPI\Client\Model\Error' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\Error' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\Error', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 503:
                    if ('\OpenAPI\Client\Model\Error' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\Error' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\Error', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\GuestReviews';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\GuestReviews',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\Error',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 401:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\Error',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 403:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\Error',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 404:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\Error',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 426:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\Error',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 429:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\Error',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 500:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\Error',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 503:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\Error',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getPropertyGuestReviewsAsync
     *
     * Property Guest Reviews
     *
     * @param  string $accept Specifies the response format that the client would like to receive back. This must be &#x60;application/json&#x60;. (required)
     * @param  string $accept_encoding Specifies the response encoding that the client would like to receive back. This must be &#x60;gzip&#x60;. (required)
     * @param  string $user_agent The &#x60;User-Agent&#x60; header string from the customer&#39;s request, as captured by your integration. If you are building an application then the &#x60;User-Agent&#x60; value should be &#x60;{app name}/{app version}&#x60;. (required)
     * @param  string $property_id Expedia Property ID.&lt;br&gt; (required)
     * @param  string $language Desired language for the response as a subset of BCP47 format that only uses hyphenated pairs of two-digit language and country codes. Use only ISO 639-1 alpha-2 language codes and ISO 3166-1 alpha-2 country codes. See [https://www.w3.org/International/articles/language-tags/](https://www.w3.org/International/articles/language-tags/)  Language Options: [https://developers.expediagroup.com/docs/rapid/resources/reference/language-options](https://developers.expediagroup.com/docs/rapid/resources/reference/language-options) (required)
     * @param  string $customer_session_id Insert your own unique value for each user session, beginning with the first API call. Continue to pass the same value for each subsequent API call during the user&#39;s session, using a new value for every new customer session.&lt;br&gt; Including this value greatly eases EPS&#39;s internal debugging process for issues with partner requests, as it explicitly links together request paths for individual user&#39;s session. (optional)
     * @param  string $billing_terms This parameter is to specify the terms of how a resulting booking should be billed. If this field is needed, the value for this will be provided to you separately. (optional)
     * @param  string $payment_terms This parameter is to specify what terms should be used when being paid for a resulting booking. If this field is needed, the value for this will be provided to you separately. (optional)
     * @param  string $partner_point_of_sale This parameter is to specify what point of sale is being used to shop and book. If this field is needed, the value for this will be provided to you separately. (optional)
     * @param  string $platform_name This parameter is to specify what platform is being used to shop and book. If this field is needed, the value for this will be provided to you separately. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getPropertyGuestReviews'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getPropertyGuestReviewsAsync($accept, $accept_encoding, $user_agent, $property_id, $language, $customer_session_id = null, $billing_terms = null, $payment_terms = null, $partner_point_of_sale = null, $platform_name = null, string $contentType = self::contentTypes['getPropertyGuestReviews'][0])
    {
        return $this->getPropertyGuestReviewsAsyncWithHttpInfo($accept, $accept_encoding, $user_agent, $property_id, $language, $customer_session_id, $billing_terms, $payment_terms, $partner_point_of_sale, $platform_name, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getPropertyGuestReviewsAsyncWithHttpInfo
     *
     * Property Guest Reviews
     *
     * @param  string $accept Specifies the response format that the client would like to receive back. This must be &#x60;application/json&#x60;. (required)
     * @param  string $accept_encoding Specifies the response encoding that the client would like to receive back. This must be &#x60;gzip&#x60;. (required)
     * @param  string $user_agent The &#x60;User-Agent&#x60; header string from the customer&#39;s request, as captured by your integration. If you are building an application then the &#x60;User-Agent&#x60; value should be &#x60;{app name}/{app version}&#x60;. (required)
     * @param  string $property_id Expedia Property ID.&lt;br&gt; (required)
     * @param  string $language Desired language for the response as a subset of BCP47 format that only uses hyphenated pairs of two-digit language and country codes. Use only ISO 639-1 alpha-2 language codes and ISO 3166-1 alpha-2 country codes. See [https://www.w3.org/International/articles/language-tags/](https://www.w3.org/International/articles/language-tags/)  Language Options: [https://developers.expediagroup.com/docs/rapid/resources/reference/language-options](https://developers.expediagroup.com/docs/rapid/resources/reference/language-options) (required)
     * @param  string $customer_session_id Insert your own unique value for each user session, beginning with the first API call. Continue to pass the same value for each subsequent API call during the user&#39;s session, using a new value for every new customer session.&lt;br&gt; Including this value greatly eases EPS&#39;s internal debugging process for issues with partner requests, as it explicitly links together request paths for individual user&#39;s session. (optional)
     * @param  string $billing_terms This parameter is to specify the terms of how a resulting booking should be billed. If this field is needed, the value for this will be provided to you separately. (optional)
     * @param  string $payment_terms This parameter is to specify what terms should be used when being paid for a resulting booking. If this field is needed, the value for this will be provided to you separately. (optional)
     * @param  string $partner_point_of_sale This parameter is to specify what point of sale is being used to shop and book. If this field is needed, the value for this will be provided to you separately. (optional)
     * @param  string $platform_name This parameter is to specify what platform is being used to shop and book. If this field is needed, the value for this will be provided to you separately. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getPropertyGuestReviews'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getPropertyGuestReviewsAsyncWithHttpInfo($accept, $accept_encoding, $user_agent, $property_id, $language, $customer_session_id = null, $billing_terms = null, $payment_terms = null, $partner_point_of_sale = null, $platform_name = null, string $contentType = self::contentTypes['getPropertyGuestReviews'][0])
    {
        $returnType = '\OpenAPI\Client\Model\GuestReviews';
        $request = $this->getPropertyGuestReviewsRequest($accept, $accept_encoding, $user_agent, $property_id, $language, $customer_session_id, $billing_terms, $payment_terms, $partner_point_of_sale, $platform_name, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getPropertyGuestReviews'
     *
     * @param  string $accept Specifies the response format that the client would like to receive back. This must be &#x60;application/json&#x60;. (required)
     * @param  string $accept_encoding Specifies the response encoding that the client would like to receive back. This must be &#x60;gzip&#x60;. (required)
     * @param  string $user_agent The &#x60;User-Agent&#x60; header string from the customer&#39;s request, as captured by your integration. If you are building an application then the &#x60;User-Agent&#x60; value should be &#x60;{app name}/{app version}&#x60;. (required)
     * @param  string $property_id Expedia Property ID.&lt;br&gt; (required)
     * @param  string $language Desired language for the response as a subset of BCP47 format that only uses hyphenated pairs of two-digit language and country codes. Use only ISO 639-1 alpha-2 language codes and ISO 3166-1 alpha-2 country codes. See [https://www.w3.org/International/articles/language-tags/](https://www.w3.org/International/articles/language-tags/)  Language Options: [https://developers.expediagroup.com/docs/rapid/resources/reference/language-options](https://developers.expediagroup.com/docs/rapid/resources/reference/language-options) (required)
     * @param  string $customer_session_id Insert your own unique value for each user session, beginning with the first API call. Continue to pass the same value for each subsequent API call during the user&#39;s session, using a new value for every new customer session.&lt;br&gt; Including this value greatly eases EPS&#39;s internal debugging process for issues with partner requests, as it explicitly links together request paths for individual user&#39;s session. (optional)
     * @param  string $billing_terms This parameter is to specify the terms of how a resulting booking should be billed. If this field is needed, the value for this will be provided to you separately. (optional)
     * @param  string $payment_terms This parameter is to specify what terms should be used when being paid for a resulting booking. If this field is needed, the value for this will be provided to you separately. (optional)
     * @param  string $partner_point_of_sale This parameter is to specify what point of sale is being used to shop and book. If this field is needed, the value for this will be provided to you separately. (optional)
     * @param  string $platform_name This parameter is to specify what platform is being used to shop and book. If this field is needed, the value for this will be provided to you separately. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getPropertyGuestReviews'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function getPropertyGuestReviewsRequest($accept, $accept_encoding, $user_agent, $property_id, $language, $customer_session_id = null, $billing_terms = null, $payment_terms = null, $partner_point_of_sale = null, $platform_name = null, string $contentType = self::contentTypes['getPropertyGuestReviews'][0])
    {

        // verify the required parameter 'accept' is set
        if ($accept === null || (is_array($accept) && count($accept) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $accept when calling getPropertyGuestReviews'
            );
        }

        // verify the required parameter 'accept_encoding' is set
        if ($accept_encoding === null || (is_array($accept_encoding) && count($accept_encoding) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $accept_encoding when calling getPropertyGuestReviews'
            );
        }

        // verify the required parameter 'user_agent' is set
        if ($user_agent === null || (is_array($user_agent) && count($user_agent) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $user_agent when calling getPropertyGuestReviews'
            );
        }

        // verify the required parameter 'property_id' is set
        if ($property_id === null || (is_array($property_id) && count($property_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $property_id when calling getPropertyGuestReviews'
            );
        }

        // verify the required parameter 'language' is set
        if ($language === null || (is_array($language) && count($language) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $language when calling getPropertyGuestReviews'
            );
        }







        $resourcePath = '/properties/{property_id}/guest-reviews';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $language,
            'language', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            true // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $billing_terms,
            'billing_terms', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $payment_terms,
            'payment_terms', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $partner_point_of_sale,
            'partner_point_of_sale', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $platform_name,
            'platform_name', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);

        // header params
        if ($accept !== null) {
            $headerParams['Accept'] = ObjectSerializer::toHeaderValue($accept);
        }
        // header params
        if ($accept_encoding !== null) {
            $headerParams['Accept-Encoding'] = ObjectSerializer::toHeaderValue($accept_encoding);
        }
        // header params
        if ($customer_session_id !== null) {
            $headerParams['Customer-Session-Id'] = ObjectSerializer::toHeaderValue($customer_session_id);
        }
        // header params
        if ($user_agent !== null) {
            $headerParams['User-Agent'] = ObjectSerializer::toHeaderValue($user_agent);
        }

        // path params
        if ($property_id !== null) {
            $resourcePath = str_replace(
                '{' . 'property_id' . '}',
                ObjectSerializer::toPathValue($property_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Create http client option
     *
     * @throws \RuntimeException on file opening failure
     * @return array of http client options
     */
    protected function createHttpClientOption()
    {
        $options = [];
        if ($this->config->getDebug()) {
            $options[RequestOptions::DEBUG] = fopen($this->config->getDebugFile(), 'a');
            if (!$options[RequestOptions::DEBUG]) {
                throw new \RuntimeException('Failed to open the debug file: ' . $this->config->getDebugFile());
            }
        }

        return $options;
    }
}
