<?php
/**
 * ShoppingApi
 * PHP version 7.4
 *
 * @category Class
 * @package  OpenAPI\Client
 * @author   OpenAPI Generator team
 * @link     https://openapi-generator.tech
 */

/**
 * Rapid
 *
 * EPS Rapid V3
 *
 * The version of the OpenAPI document: v3
 * Generated by: https://openapi-generator.tech
 * OpenAPI Generator version: 7.0.1
 */

/**
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

namespace OpenAPI\Client\Api;

use GuzzleHttp\Client;
use GuzzleHttp\ClientInterface;
use GuzzleHttp\Exception\ConnectException;
use GuzzleHttp\Exception\RequestException;
use GuzzleHttp\Psr7\MultipartStream;
use GuzzleHttp\Psr7\Request;
use GuzzleHttp\RequestOptions;
use OpenAPI\Client\ApiException;
use OpenAPI\Client\Configuration;
use OpenAPI\Client\HeaderSelector;
use OpenAPI\Client\ObjectSerializer;

/**
 * ShoppingApi Class Doc Comment
 *
 * @category Class
 * @package  OpenAPI\Client
 * @author   OpenAPI Generator team
 * @link     https://openapi-generator.tech
 */
class ShoppingApi
{
    /**
     * @var ClientInterface
     */
    protected $client;

    /**
     * @var Configuration
     */
    protected $config;

    /**
     * @var HeaderSelector
     */
    protected $headerSelector;

    /**
     * @var int Host index
     */
    protected $hostIndex;

    /** @var string[] $contentTypes **/
    public const contentTypes = [
        'getAdditionalAvailability' => [
            'application/json',
        ],
        'getAvailability' => [
            'application/json',
        ],
        'getCalendarAvailability' => [
            'application/json',
        ],
        'getPaymentOptions' => [
            'application/json',
        ],
        'priceCheck' => [
            'application/json',
        ],
    ];

/**
     * @param ClientInterface $client
     * @param Configuration   $config
     * @param HeaderSelector  $selector
     * @param int             $hostIndex (Optional) host index to select the list of hosts if defined in the OpenAPI spec
     */
    public function __construct(
        ClientInterface $client = null,
        Configuration $config = null,
        HeaderSelector $selector = null,
        $hostIndex = 0
    ) {
        $this->client = $client ?: new Client();
        $this->config = $config ?: new Configuration();
        $this->headerSelector = $selector ?: new HeaderSelector();
        $this->hostIndex = $hostIndex;
    }

    /**
     * Set the host index
     *
     * @param int $hostIndex Host index (required)
     */
    public function setHostIndex($hostIndex): void
    {
        $this->hostIndex = $hostIndex;
    }

    /**
     * Get the host index
     *
     * @return int Host index
     */
    public function getHostIndex()
    {
        return $this->hostIndex;
    }

    /**
     * @return Configuration
     */
    public function getConfig()
    {
        return $this->config;
    }

    /**
     * Operation getAdditionalAvailability
     *
     * Get additional property room rates and availability
     *
     * @param  string $accept Specifies the response format that the client would like to receive back. This must be &#x60;application/json&#x60;. (required)
     * @param  string $accept_encoding Specifies the response encoding that the client would like to receive back. This must be &#x60;gzip&#x60;. (required)
     * @param  string $user_agent The &#x60;User-Agent&#x60; header string from the customer&#39;s request, as captured by your integration. If you are building an application then the &#x60;User-Agent&#x60; value should be &#x60;{app name}/{app version}&#x60;. (required)
     * @param  string $property_id Expedia Property ID.&lt;br&gt; (required)
     * @param  string $token A hashed collection of query parameters. Used to maintain state across calls. This token is provided as part of the &#x60;additional_rates&#x60; link from the shop response, or the &#x60;shop&#x60; link on a &#x60;sold_out&#x60; price check response. It is also provided from the &#x60;shop_for_change&#x60; link on an itinerary retrieve. (required)
     * @param  string $customer_ip IP address of the customer, as captured by your integration.&lt;br&gt; Ensure your integration passes the customer&#39;s IP, not your own. This value helps determine their location and assign the correct payment gateway.&lt;br&gt; Also used for fraud recovery and other important analytics. (optional)
     * @param  string $customer_session_id Insert your own unique value for each user session, beginning with the first API call. Continue to pass the same value for each subsequent API call during the user&#39;s session, using a new value for every new customer session.&lt;br&gt; Including this value greatly eases EPS&#39;s internal debugging process for issues with partner requests, as it explicitly links together request paths for individual user&#39;s session. (optional)
     * @param  string $test Shop calls have a test header that can be used to return set responses with the following keywords:&lt;br&gt; * &#x60;standard&#x60; * &#x60;service_unavailable&#x60; * &#x60;unknown_internal_error&#x60; * &#x60;no_availability&#x60; * &#x60;forbidden&#x60; (optional)
     * @param  string $checkin Check-in date, in ISO 8601 format (YYYY-MM-DD)&lt;br&gt; Note: Only needed for hard change if desired check-in date is different than original booking. If specified must also specify &#x60;checkout&#x60;. (optional)
     * @param  string $checkout Check-out date, in ISO 8601 format (YYYY-MM-DD). Availability can be searched up to 500 days in advance of this date. Total length of stay cannot exceed 28 nights.&lt;br&gt; Note: Only needed for hard change if desired check-out date is different than original booking. If specified must also specify &#x60;checkin&#x60;.&lt;br&gt; (optional)
     * @param  string[] $exclusion Single exclusion type. Send multiple instances of this parameter to request multiple exclusions.&lt;br&gt; Note: Optional parameter for use with hard change requests. &lt;br&gt; * &#x60;refundable_damage_deposit&#x60; - Excludes rates with refundable damage deposits from the response. (optional)
     * @param  string[] $filter Single filter type. Send multiple instances of this parameter to request multiple filters.&lt;br&gt; Note: Optional parameter for use with hard change requests.&lt;br&gt; * &#x60;refundable&#x60; - Filters results to only show fully refundable rates. * &#x60;expedia_collect&#x60; - Filters results to only show rates where payment is collected by Expedia at the time of booking. These properties can be eligible for payments via Expedia Affiliate Collect(EAC). * &#x60;property_collect&#x60; - Filters results to only show rates where payment is collected by the property after booking. This can include rates that require a deposit by the property, dependent upon the deposit policies. (optional)
     * @param  string[] $occupancy Defines the requested occupancy for a single room. Each room must have at least 1 adult occupant.&lt;br&gt; Format: &#x60;numberOfAdults[-firstChildAge[,nextChildAge]]&#x60;&lt;br&gt; To request multiple rooms (of the same type), include one instance of occupancy for each room requested. Up to 8 rooms may be requested or booked at once.&lt;br&gt; Note: Only needed for hard change if desired occupancy is different than original booking.&lt;br&gt; Examples: * 2 adults, one 9-year-old and one 4-year-old would be represented by &#x60;occupancy&#x3D;2-9,4&#x60;.&lt;br&gt; * A multi-room request to lodge an additional 2 adults would be represented by &#x60;occupancy&#x3D;2-9,4&amp;occupancy&#x3D;2&#x60; (optional)
     * @param  string[] $rate_option Request specific rate options for each property. Send multiple instances of this parameter to request multiple rate options. Note: Optional parameter for use with hard change requests.&lt;br&gt; Accepted values:&lt;br&gt; * &#x60;member&#x60; - Return member rates for each property. This feature must be enabled and requires a user to be logged in to request these rates. * &#x60;net_rates&#x60; - Return net rates for each property. This feature must be enabled to request these rates. * &#x60;cross_sell&#x60; - Identify if the traffic is coming from a cross sell booking. Where the traveler has booked another service (flight, car, activities...) before hotel. (optional)
     * @param  string $sales_channel Provide the sales channel if you wish to override the sales_channel provided in the previous call. EPS dynamically provides the best content for optimal conversion on each sales channel.&lt;br&gt; Note: Must specify this value for hard change requests.&lt;br&gt; * &#x60;website&#x60; - Standard website accessed from the customer&#39;s computer * &#x60;agent_tool&#x60; - Your own agent tool used by your call center or retail store agent * &#x60;mobile_app&#x60; - An application installed on a phone or tablet device * &#x60;mobile_web&#x60; - A web browser application on a phone or tablet device * &#x60;meta&#x60; - Rates will be passed to and displayed on a 3rd party comparison website * &#x60;cache&#x60; - Rates will be used to populate a local cache (optional)
     * @param  string $sales_environment Provide the sales environment if you wish to override the sales_environment provided in the previous call. EPS dynamically provides the best content for optimal conversion. If you have a sales environment that is not currently supported in this list, please contact our support team.&lt;br&gt; Note: Must specify this value for hard change requests.&lt;br&gt; * &#x60;hotel_package&#x60; - Standard website accessed from the customer&#39;s computer * &#x60;hotel_only&#x60; - Your own agent tool used by your call center or retail store agent * &#x60;loyalty&#x60; - An application installed on a phone or tablet device (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getAdditionalAvailability'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\PropertyAvailability[]|\OpenAPI\Client\Model\Error|\OpenAPI\Client\Model\Error|\OpenAPI\Client\Model\Error|\OpenAPI\Client\Model\Error|\OpenAPI\Client\Model\Error|\OpenAPI\Client\Model\Error|\OpenAPI\Client\Model\Error
     */
    public function getAdditionalAvailability($accept, $accept_encoding, $user_agent, $property_id, $token, $customer_ip = null, $customer_session_id = null, $test = null, $checkin = null, $checkout = null, $exclusion = null, $filter = null, $occupancy = null, $rate_option = null, $sales_channel = null, $sales_environment = null, string $contentType = self::contentTypes['getAdditionalAvailability'][0])
    {
        list($response) = $this->getAdditionalAvailabilityWithHttpInfo($accept, $accept_encoding, $user_agent, $property_id, $token, $customer_ip, $customer_session_id, $test, $checkin, $checkout, $exclusion, $filter, $occupancy, $rate_option, $sales_channel, $sales_environment, $contentType);
        return $response;
    }

    /**
     * Operation getAdditionalAvailabilityWithHttpInfo
     *
     * Get additional property room rates and availability
     *
     * @param  string $accept Specifies the response format that the client would like to receive back. This must be &#x60;application/json&#x60;. (required)
     * @param  string $accept_encoding Specifies the response encoding that the client would like to receive back. This must be &#x60;gzip&#x60;. (required)
     * @param  string $user_agent The &#x60;User-Agent&#x60; header string from the customer&#39;s request, as captured by your integration. If you are building an application then the &#x60;User-Agent&#x60; value should be &#x60;{app name}/{app version}&#x60;. (required)
     * @param  string $property_id Expedia Property ID.&lt;br&gt; (required)
     * @param  string $token A hashed collection of query parameters. Used to maintain state across calls. This token is provided as part of the &#x60;additional_rates&#x60; link from the shop response, or the &#x60;shop&#x60; link on a &#x60;sold_out&#x60; price check response. It is also provided from the &#x60;shop_for_change&#x60; link on an itinerary retrieve. (required)
     * @param  string $customer_ip IP address of the customer, as captured by your integration.&lt;br&gt; Ensure your integration passes the customer&#39;s IP, not your own. This value helps determine their location and assign the correct payment gateway.&lt;br&gt; Also used for fraud recovery and other important analytics. (optional)
     * @param  string $customer_session_id Insert your own unique value for each user session, beginning with the first API call. Continue to pass the same value for each subsequent API call during the user&#39;s session, using a new value for every new customer session.&lt;br&gt; Including this value greatly eases EPS&#39;s internal debugging process for issues with partner requests, as it explicitly links together request paths for individual user&#39;s session. (optional)
     * @param  string $test Shop calls have a test header that can be used to return set responses with the following keywords:&lt;br&gt; * &#x60;standard&#x60; * &#x60;service_unavailable&#x60; * &#x60;unknown_internal_error&#x60; * &#x60;no_availability&#x60; * &#x60;forbidden&#x60; (optional)
     * @param  string $checkin Check-in date, in ISO 8601 format (YYYY-MM-DD)&lt;br&gt; Note: Only needed for hard change if desired check-in date is different than original booking. If specified must also specify &#x60;checkout&#x60;. (optional)
     * @param  string $checkout Check-out date, in ISO 8601 format (YYYY-MM-DD). Availability can be searched up to 500 days in advance of this date. Total length of stay cannot exceed 28 nights.&lt;br&gt; Note: Only needed for hard change if desired check-out date is different than original booking. If specified must also specify &#x60;checkin&#x60;.&lt;br&gt; (optional)
     * @param  string[] $exclusion Single exclusion type. Send multiple instances of this parameter to request multiple exclusions.&lt;br&gt; Note: Optional parameter for use with hard change requests. &lt;br&gt; * &#x60;refundable_damage_deposit&#x60; - Excludes rates with refundable damage deposits from the response. (optional)
     * @param  string[] $filter Single filter type. Send multiple instances of this parameter to request multiple filters.&lt;br&gt; Note: Optional parameter for use with hard change requests.&lt;br&gt; * &#x60;refundable&#x60; - Filters results to only show fully refundable rates. * &#x60;expedia_collect&#x60; - Filters results to only show rates where payment is collected by Expedia at the time of booking. These properties can be eligible for payments via Expedia Affiliate Collect(EAC). * &#x60;property_collect&#x60; - Filters results to only show rates where payment is collected by the property after booking. This can include rates that require a deposit by the property, dependent upon the deposit policies. (optional)
     * @param  string[] $occupancy Defines the requested occupancy for a single room. Each room must have at least 1 adult occupant.&lt;br&gt; Format: &#x60;numberOfAdults[-firstChildAge[,nextChildAge]]&#x60;&lt;br&gt; To request multiple rooms (of the same type), include one instance of occupancy for each room requested. Up to 8 rooms may be requested or booked at once.&lt;br&gt; Note: Only needed for hard change if desired occupancy is different than original booking.&lt;br&gt; Examples: * 2 adults, one 9-year-old and one 4-year-old would be represented by &#x60;occupancy&#x3D;2-9,4&#x60;.&lt;br&gt; * A multi-room request to lodge an additional 2 adults would be represented by &#x60;occupancy&#x3D;2-9,4&amp;occupancy&#x3D;2&#x60; (optional)
     * @param  string[] $rate_option Request specific rate options for each property. Send multiple instances of this parameter to request multiple rate options. Note: Optional parameter for use with hard change requests.&lt;br&gt; Accepted values:&lt;br&gt; * &#x60;member&#x60; - Return member rates for each property. This feature must be enabled and requires a user to be logged in to request these rates. * &#x60;net_rates&#x60; - Return net rates for each property. This feature must be enabled to request these rates. * &#x60;cross_sell&#x60; - Identify if the traffic is coming from a cross sell booking. Where the traveler has booked another service (flight, car, activities...) before hotel. (optional)
     * @param  string $sales_channel Provide the sales channel if you wish to override the sales_channel provided in the previous call. EPS dynamically provides the best content for optimal conversion on each sales channel.&lt;br&gt; Note: Must specify this value for hard change requests.&lt;br&gt; * &#x60;website&#x60; - Standard website accessed from the customer&#39;s computer * &#x60;agent_tool&#x60; - Your own agent tool used by your call center or retail store agent * &#x60;mobile_app&#x60; - An application installed on a phone or tablet device * &#x60;mobile_web&#x60; - A web browser application on a phone or tablet device * &#x60;meta&#x60; - Rates will be passed to and displayed on a 3rd party comparison website * &#x60;cache&#x60; - Rates will be used to populate a local cache (optional)
     * @param  string $sales_environment Provide the sales environment if you wish to override the sales_environment provided in the previous call. EPS dynamically provides the best content for optimal conversion. If you have a sales environment that is not currently supported in this list, please contact our support team.&lt;br&gt; Note: Must specify this value for hard change requests.&lt;br&gt; * &#x60;hotel_package&#x60; - Standard website accessed from the customer&#39;s computer * &#x60;hotel_only&#x60; - Your own agent tool used by your call center or retail store agent * &#x60;loyalty&#x60; - An application installed on a phone or tablet device (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getAdditionalAvailability'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\PropertyAvailability[]|\OpenAPI\Client\Model\Error|\OpenAPI\Client\Model\Error|\OpenAPI\Client\Model\Error|\OpenAPI\Client\Model\Error|\OpenAPI\Client\Model\Error|\OpenAPI\Client\Model\Error|\OpenAPI\Client\Model\Error, HTTP status code, HTTP response headers (array of strings)
     */
    public function getAdditionalAvailabilityWithHttpInfo($accept, $accept_encoding, $user_agent, $property_id, $token, $customer_ip = null, $customer_session_id = null, $test = null, $checkin = null, $checkout = null, $exclusion = null, $filter = null, $occupancy = null, $rate_option = null, $sales_channel = null, $sales_environment = null, string $contentType = self::contentTypes['getAdditionalAvailability'][0])
    {
        $request = $this->getAdditionalAvailabilityRequest($accept, $accept_encoding, $user_agent, $property_id, $token, $customer_ip, $customer_session_id, $test, $checkin, $checkout, $exclusion, $filter, $occupancy, $rate_option, $sales_channel, $sales_environment, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\PropertyAvailability[]' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\PropertyAvailability[]' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\PropertyAvailability[]', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 400:
                    if ('\OpenAPI\Client\Model\Error' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\Error' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\Error', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 401:
                    if ('\OpenAPI\Client\Model\Error' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\Error' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\Error', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 403:
                    if ('\OpenAPI\Client\Model\Error' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\Error' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\Error', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 426:
                    if ('\OpenAPI\Client\Model\Error' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\Error' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\Error', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 429:
                    if ('\OpenAPI\Client\Model\Error' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\Error' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\Error', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 500:
                    if ('\OpenAPI\Client\Model\Error' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\Error' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\Error', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 503:
                    if ('\OpenAPI\Client\Model\Error' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\Error' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\Error', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\PropertyAvailability[]';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\PropertyAvailability[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\Error',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 401:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\Error',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 403:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\Error',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 426:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\Error',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 429:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\Error',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 500:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\Error',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 503:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\Error',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getAdditionalAvailabilityAsync
     *
     * Get additional property room rates and availability
     *
     * @param  string $accept Specifies the response format that the client would like to receive back. This must be &#x60;application/json&#x60;. (required)
     * @param  string $accept_encoding Specifies the response encoding that the client would like to receive back. This must be &#x60;gzip&#x60;. (required)
     * @param  string $user_agent The &#x60;User-Agent&#x60; header string from the customer&#39;s request, as captured by your integration. If you are building an application then the &#x60;User-Agent&#x60; value should be &#x60;{app name}/{app version}&#x60;. (required)
     * @param  string $property_id Expedia Property ID.&lt;br&gt; (required)
     * @param  string $token A hashed collection of query parameters. Used to maintain state across calls. This token is provided as part of the &#x60;additional_rates&#x60; link from the shop response, or the &#x60;shop&#x60; link on a &#x60;sold_out&#x60; price check response. It is also provided from the &#x60;shop_for_change&#x60; link on an itinerary retrieve. (required)
     * @param  string $customer_ip IP address of the customer, as captured by your integration.&lt;br&gt; Ensure your integration passes the customer&#39;s IP, not your own. This value helps determine their location and assign the correct payment gateway.&lt;br&gt; Also used for fraud recovery and other important analytics. (optional)
     * @param  string $customer_session_id Insert your own unique value for each user session, beginning with the first API call. Continue to pass the same value for each subsequent API call during the user&#39;s session, using a new value for every new customer session.&lt;br&gt; Including this value greatly eases EPS&#39;s internal debugging process for issues with partner requests, as it explicitly links together request paths for individual user&#39;s session. (optional)
     * @param  string $test Shop calls have a test header that can be used to return set responses with the following keywords:&lt;br&gt; * &#x60;standard&#x60; * &#x60;service_unavailable&#x60; * &#x60;unknown_internal_error&#x60; * &#x60;no_availability&#x60; * &#x60;forbidden&#x60; (optional)
     * @param  string $checkin Check-in date, in ISO 8601 format (YYYY-MM-DD)&lt;br&gt; Note: Only needed for hard change if desired check-in date is different than original booking. If specified must also specify &#x60;checkout&#x60;. (optional)
     * @param  string $checkout Check-out date, in ISO 8601 format (YYYY-MM-DD). Availability can be searched up to 500 days in advance of this date. Total length of stay cannot exceed 28 nights.&lt;br&gt; Note: Only needed for hard change if desired check-out date is different than original booking. If specified must also specify &#x60;checkin&#x60;.&lt;br&gt; (optional)
     * @param  string[] $exclusion Single exclusion type. Send multiple instances of this parameter to request multiple exclusions.&lt;br&gt; Note: Optional parameter for use with hard change requests. &lt;br&gt; * &#x60;refundable_damage_deposit&#x60; - Excludes rates with refundable damage deposits from the response. (optional)
     * @param  string[] $filter Single filter type. Send multiple instances of this parameter to request multiple filters.&lt;br&gt; Note: Optional parameter for use with hard change requests.&lt;br&gt; * &#x60;refundable&#x60; - Filters results to only show fully refundable rates. * &#x60;expedia_collect&#x60; - Filters results to only show rates where payment is collected by Expedia at the time of booking. These properties can be eligible for payments via Expedia Affiliate Collect(EAC). * &#x60;property_collect&#x60; - Filters results to only show rates where payment is collected by the property after booking. This can include rates that require a deposit by the property, dependent upon the deposit policies. (optional)
     * @param  string[] $occupancy Defines the requested occupancy for a single room. Each room must have at least 1 adult occupant.&lt;br&gt; Format: &#x60;numberOfAdults[-firstChildAge[,nextChildAge]]&#x60;&lt;br&gt; To request multiple rooms (of the same type), include one instance of occupancy for each room requested. Up to 8 rooms may be requested or booked at once.&lt;br&gt; Note: Only needed for hard change if desired occupancy is different than original booking.&lt;br&gt; Examples: * 2 adults, one 9-year-old and one 4-year-old would be represented by &#x60;occupancy&#x3D;2-9,4&#x60;.&lt;br&gt; * A multi-room request to lodge an additional 2 adults would be represented by &#x60;occupancy&#x3D;2-9,4&amp;occupancy&#x3D;2&#x60; (optional)
     * @param  string[] $rate_option Request specific rate options for each property. Send multiple instances of this parameter to request multiple rate options. Note: Optional parameter for use with hard change requests.&lt;br&gt; Accepted values:&lt;br&gt; * &#x60;member&#x60; - Return member rates for each property. This feature must be enabled and requires a user to be logged in to request these rates. * &#x60;net_rates&#x60; - Return net rates for each property. This feature must be enabled to request these rates. * &#x60;cross_sell&#x60; - Identify if the traffic is coming from a cross sell booking. Where the traveler has booked another service (flight, car, activities...) before hotel. (optional)
     * @param  string $sales_channel Provide the sales channel if you wish to override the sales_channel provided in the previous call. EPS dynamically provides the best content for optimal conversion on each sales channel.&lt;br&gt; Note: Must specify this value for hard change requests.&lt;br&gt; * &#x60;website&#x60; - Standard website accessed from the customer&#39;s computer * &#x60;agent_tool&#x60; - Your own agent tool used by your call center or retail store agent * &#x60;mobile_app&#x60; - An application installed on a phone or tablet device * &#x60;mobile_web&#x60; - A web browser application on a phone or tablet device * &#x60;meta&#x60; - Rates will be passed to and displayed on a 3rd party comparison website * &#x60;cache&#x60; - Rates will be used to populate a local cache (optional)
     * @param  string $sales_environment Provide the sales environment if you wish to override the sales_environment provided in the previous call. EPS dynamically provides the best content for optimal conversion. If you have a sales environment that is not currently supported in this list, please contact our support team.&lt;br&gt; Note: Must specify this value for hard change requests.&lt;br&gt; * &#x60;hotel_package&#x60; - Standard website accessed from the customer&#39;s computer * &#x60;hotel_only&#x60; - Your own agent tool used by your call center or retail store agent * &#x60;loyalty&#x60; - An application installed on a phone or tablet device (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getAdditionalAvailability'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getAdditionalAvailabilityAsync($accept, $accept_encoding, $user_agent, $property_id, $token, $customer_ip = null, $customer_session_id = null, $test = null, $checkin = null, $checkout = null, $exclusion = null, $filter = null, $occupancy = null, $rate_option = null, $sales_channel = null, $sales_environment = null, string $contentType = self::contentTypes['getAdditionalAvailability'][0])
    {
        return $this->getAdditionalAvailabilityAsyncWithHttpInfo($accept, $accept_encoding, $user_agent, $property_id, $token, $customer_ip, $customer_session_id, $test, $checkin, $checkout, $exclusion, $filter, $occupancy, $rate_option, $sales_channel, $sales_environment, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getAdditionalAvailabilityAsyncWithHttpInfo
     *
     * Get additional property room rates and availability
     *
     * @param  string $accept Specifies the response format that the client would like to receive back. This must be &#x60;application/json&#x60;. (required)
     * @param  string $accept_encoding Specifies the response encoding that the client would like to receive back. This must be &#x60;gzip&#x60;. (required)
     * @param  string $user_agent The &#x60;User-Agent&#x60; header string from the customer&#39;s request, as captured by your integration. If you are building an application then the &#x60;User-Agent&#x60; value should be &#x60;{app name}/{app version}&#x60;. (required)
     * @param  string $property_id Expedia Property ID.&lt;br&gt; (required)
     * @param  string $token A hashed collection of query parameters. Used to maintain state across calls. This token is provided as part of the &#x60;additional_rates&#x60; link from the shop response, or the &#x60;shop&#x60; link on a &#x60;sold_out&#x60; price check response. It is also provided from the &#x60;shop_for_change&#x60; link on an itinerary retrieve. (required)
     * @param  string $customer_ip IP address of the customer, as captured by your integration.&lt;br&gt; Ensure your integration passes the customer&#39;s IP, not your own. This value helps determine their location and assign the correct payment gateway.&lt;br&gt; Also used for fraud recovery and other important analytics. (optional)
     * @param  string $customer_session_id Insert your own unique value for each user session, beginning with the first API call. Continue to pass the same value for each subsequent API call during the user&#39;s session, using a new value for every new customer session.&lt;br&gt; Including this value greatly eases EPS&#39;s internal debugging process for issues with partner requests, as it explicitly links together request paths for individual user&#39;s session. (optional)
     * @param  string $test Shop calls have a test header that can be used to return set responses with the following keywords:&lt;br&gt; * &#x60;standard&#x60; * &#x60;service_unavailable&#x60; * &#x60;unknown_internal_error&#x60; * &#x60;no_availability&#x60; * &#x60;forbidden&#x60; (optional)
     * @param  string $checkin Check-in date, in ISO 8601 format (YYYY-MM-DD)&lt;br&gt; Note: Only needed for hard change if desired check-in date is different than original booking. If specified must also specify &#x60;checkout&#x60;. (optional)
     * @param  string $checkout Check-out date, in ISO 8601 format (YYYY-MM-DD). Availability can be searched up to 500 days in advance of this date. Total length of stay cannot exceed 28 nights.&lt;br&gt; Note: Only needed for hard change if desired check-out date is different than original booking. If specified must also specify &#x60;checkin&#x60;.&lt;br&gt; (optional)
     * @param  string[] $exclusion Single exclusion type. Send multiple instances of this parameter to request multiple exclusions.&lt;br&gt; Note: Optional parameter for use with hard change requests. &lt;br&gt; * &#x60;refundable_damage_deposit&#x60; - Excludes rates with refundable damage deposits from the response. (optional)
     * @param  string[] $filter Single filter type. Send multiple instances of this parameter to request multiple filters.&lt;br&gt; Note: Optional parameter for use with hard change requests.&lt;br&gt; * &#x60;refundable&#x60; - Filters results to only show fully refundable rates. * &#x60;expedia_collect&#x60; - Filters results to only show rates where payment is collected by Expedia at the time of booking. These properties can be eligible for payments via Expedia Affiliate Collect(EAC). * &#x60;property_collect&#x60; - Filters results to only show rates where payment is collected by the property after booking. This can include rates that require a deposit by the property, dependent upon the deposit policies. (optional)
     * @param  string[] $occupancy Defines the requested occupancy for a single room. Each room must have at least 1 adult occupant.&lt;br&gt; Format: &#x60;numberOfAdults[-firstChildAge[,nextChildAge]]&#x60;&lt;br&gt; To request multiple rooms (of the same type), include one instance of occupancy for each room requested. Up to 8 rooms may be requested or booked at once.&lt;br&gt; Note: Only needed for hard change if desired occupancy is different than original booking.&lt;br&gt; Examples: * 2 adults, one 9-year-old and one 4-year-old would be represented by &#x60;occupancy&#x3D;2-9,4&#x60;.&lt;br&gt; * A multi-room request to lodge an additional 2 adults would be represented by &#x60;occupancy&#x3D;2-9,4&amp;occupancy&#x3D;2&#x60; (optional)
     * @param  string[] $rate_option Request specific rate options for each property. Send multiple instances of this parameter to request multiple rate options. Note: Optional parameter for use with hard change requests.&lt;br&gt; Accepted values:&lt;br&gt; * &#x60;member&#x60; - Return member rates for each property. This feature must be enabled and requires a user to be logged in to request these rates. * &#x60;net_rates&#x60; - Return net rates for each property. This feature must be enabled to request these rates. * &#x60;cross_sell&#x60; - Identify if the traffic is coming from a cross sell booking. Where the traveler has booked another service (flight, car, activities...) before hotel. (optional)
     * @param  string $sales_channel Provide the sales channel if you wish to override the sales_channel provided in the previous call. EPS dynamically provides the best content for optimal conversion on each sales channel.&lt;br&gt; Note: Must specify this value for hard change requests.&lt;br&gt; * &#x60;website&#x60; - Standard website accessed from the customer&#39;s computer * &#x60;agent_tool&#x60; - Your own agent tool used by your call center or retail store agent * &#x60;mobile_app&#x60; - An application installed on a phone or tablet device * &#x60;mobile_web&#x60; - A web browser application on a phone or tablet device * &#x60;meta&#x60; - Rates will be passed to and displayed on a 3rd party comparison website * &#x60;cache&#x60; - Rates will be used to populate a local cache (optional)
     * @param  string $sales_environment Provide the sales environment if you wish to override the sales_environment provided in the previous call. EPS dynamically provides the best content for optimal conversion. If you have a sales environment that is not currently supported in this list, please contact our support team.&lt;br&gt; Note: Must specify this value for hard change requests.&lt;br&gt; * &#x60;hotel_package&#x60; - Standard website accessed from the customer&#39;s computer * &#x60;hotel_only&#x60; - Your own agent tool used by your call center or retail store agent * &#x60;loyalty&#x60; - An application installed on a phone or tablet device (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getAdditionalAvailability'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getAdditionalAvailabilityAsyncWithHttpInfo($accept, $accept_encoding, $user_agent, $property_id, $token, $customer_ip = null, $customer_session_id = null, $test = null, $checkin = null, $checkout = null, $exclusion = null, $filter = null, $occupancy = null, $rate_option = null, $sales_channel = null, $sales_environment = null, string $contentType = self::contentTypes['getAdditionalAvailability'][0])
    {
        $returnType = '\OpenAPI\Client\Model\PropertyAvailability[]';
        $request = $this->getAdditionalAvailabilityRequest($accept, $accept_encoding, $user_agent, $property_id, $token, $customer_ip, $customer_session_id, $test, $checkin, $checkout, $exclusion, $filter, $occupancy, $rate_option, $sales_channel, $sales_environment, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getAdditionalAvailability'
     *
     * @param  string $accept Specifies the response format that the client would like to receive back. This must be &#x60;application/json&#x60;. (required)
     * @param  string $accept_encoding Specifies the response encoding that the client would like to receive back. This must be &#x60;gzip&#x60;. (required)
     * @param  string $user_agent The &#x60;User-Agent&#x60; header string from the customer&#39;s request, as captured by your integration. If you are building an application then the &#x60;User-Agent&#x60; value should be &#x60;{app name}/{app version}&#x60;. (required)
     * @param  string $property_id Expedia Property ID.&lt;br&gt; (required)
     * @param  string $token A hashed collection of query parameters. Used to maintain state across calls. This token is provided as part of the &#x60;additional_rates&#x60; link from the shop response, or the &#x60;shop&#x60; link on a &#x60;sold_out&#x60; price check response. It is also provided from the &#x60;shop_for_change&#x60; link on an itinerary retrieve. (required)
     * @param  string $customer_ip IP address of the customer, as captured by your integration.&lt;br&gt; Ensure your integration passes the customer&#39;s IP, not your own. This value helps determine their location and assign the correct payment gateway.&lt;br&gt; Also used for fraud recovery and other important analytics. (optional)
     * @param  string $customer_session_id Insert your own unique value for each user session, beginning with the first API call. Continue to pass the same value for each subsequent API call during the user&#39;s session, using a new value for every new customer session.&lt;br&gt; Including this value greatly eases EPS&#39;s internal debugging process for issues with partner requests, as it explicitly links together request paths for individual user&#39;s session. (optional)
     * @param  string $test Shop calls have a test header that can be used to return set responses with the following keywords:&lt;br&gt; * &#x60;standard&#x60; * &#x60;service_unavailable&#x60; * &#x60;unknown_internal_error&#x60; * &#x60;no_availability&#x60; * &#x60;forbidden&#x60; (optional)
     * @param  string $checkin Check-in date, in ISO 8601 format (YYYY-MM-DD)&lt;br&gt; Note: Only needed for hard change if desired check-in date is different than original booking. If specified must also specify &#x60;checkout&#x60;. (optional)
     * @param  string $checkout Check-out date, in ISO 8601 format (YYYY-MM-DD). Availability can be searched up to 500 days in advance of this date. Total length of stay cannot exceed 28 nights.&lt;br&gt; Note: Only needed for hard change if desired check-out date is different than original booking. If specified must also specify &#x60;checkin&#x60;.&lt;br&gt; (optional)
     * @param  string[] $exclusion Single exclusion type. Send multiple instances of this parameter to request multiple exclusions.&lt;br&gt; Note: Optional parameter for use with hard change requests. &lt;br&gt; * &#x60;refundable_damage_deposit&#x60; - Excludes rates with refundable damage deposits from the response. (optional)
     * @param  string[] $filter Single filter type. Send multiple instances of this parameter to request multiple filters.&lt;br&gt; Note: Optional parameter for use with hard change requests.&lt;br&gt; * &#x60;refundable&#x60; - Filters results to only show fully refundable rates. * &#x60;expedia_collect&#x60; - Filters results to only show rates where payment is collected by Expedia at the time of booking. These properties can be eligible for payments via Expedia Affiliate Collect(EAC). * &#x60;property_collect&#x60; - Filters results to only show rates where payment is collected by the property after booking. This can include rates that require a deposit by the property, dependent upon the deposit policies. (optional)
     * @param  string[] $occupancy Defines the requested occupancy for a single room. Each room must have at least 1 adult occupant.&lt;br&gt; Format: &#x60;numberOfAdults[-firstChildAge[,nextChildAge]]&#x60;&lt;br&gt; To request multiple rooms (of the same type), include one instance of occupancy for each room requested. Up to 8 rooms may be requested or booked at once.&lt;br&gt; Note: Only needed for hard change if desired occupancy is different than original booking.&lt;br&gt; Examples: * 2 adults, one 9-year-old and one 4-year-old would be represented by &#x60;occupancy&#x3D;2-9,4&#x60;.&lt;br&gt; * A multi-room request to lodge an additional 2 adults would be represented by &#x60;occupancy&#x3D;2-9,4&amp;occupancy&#x3D;2&#x60; (optional)
     * @param  string[] $rate_option Request specific rate options for each property. Send multiple instances of this parameter to request multiple rate options. Note: Optional parameter for use with hard change requests.&lt;br&gt; Accepted values:&lt;br&gt; * &#x60;member&#x60; - Return member rates for each property. This feature must be enabled and requires a user to be logged in to request these rates. * &#x60;net_rates&#x60; - Return net rates for each property. This feature must be enabled to request these rates. * &#x60;cross_sell&#x60; - Identify if the traffic is coming from a cross sell booking. Where the traveler has booked another service (flight, car, activities...) before hotel. (optional)
     * @param  string $sales_channel Provide the sales channel if you wish to override the sales_channel provided in the previous call. EPS dynamically provides the best content for optimal conversion on each sales channel.&lt;br&gt; Note: Must specify this value for hard change requests.&lt;br&gt; * &#x60;website&#x60; - Standard website accessed from the customer&#39;s computer * &#x60;agent_tool&#x60; - Your own agent tool used by your call center or retail store agent * &#x60;mobile_app&#x60; - An application installed on a phone or tablet device * &#x60;mobile_web&#x60; - A web browser application on a phone or tablet device * &#x60;meta&#x60; - Rates will be passed to and displayed on a 3rd party comparison website * &#x60;cache&#x60; - Rates will be used to populate a local cache (optional)
     * @param  string $sales_environment Provide the sales environment if you wish to override the sales_environment provided in the previous call. EPS dynamically provides the best content for optimal conversion. If you have a sales environment that is not currently supported in this list, please contact our support team.&lt;br&gt; Note: Must specify this value for hard change requests.&lt;br&gt; * &#x60;hotel_package&#x60; - Standard website accessed from the customer&#39;s computer * &#x60;hotel_only&#x60; - Your own agent tool used by your call center or retail store agent * &#x60;loyalty&#x60; - An application installed on a phone or tablet device (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getAdditionalAvailability'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function getAdditionalAvailabilityRequest($accept, $accept_encoding, $user_agent, $property_id, $token, $customer_ip = null, $customer_session_id = null, $test = null, $checkin = null, $checkout = null, $exclusion = null, $filter = null, $occupancy = null, $rate_option = null, $sales_channel = null, $sales_environment = null, string $contentType = self::contentTypes['getAdditionalAvailability'][0])
    {

        // verify the required parameter 'accept' is set
        if ($accept === null || (is_array($accept) && count($accept) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $accept when calling getAdditionalAvailability'
            );
        }

        // verify the required parameter 'accept_encoding' is set
        if ($accept_encoding === null || (is_array($accept_encoding) && count($accept_encoding) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $accept_encoding when calling getAdditionalAvailability'
            );
        }

        // verify the required parameter 'user_agent' is set
        if ($user_agent === null || (is_array($user_agent) && count($user_agent) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $user_agent when calling getAdditionalAvailability'
            );
        }

        // verify the required parameter 'property_id' is set
        if ($property_id === null || (is_array($property_id) && count($property_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $property_id when calling getAdditionalAvailability'
            );
        }

        // verify the required parameter 'token' is set
        if ($token === null || (is_array($token) && count($token) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $token when calling getAdditionalAvailability'
            );
        }













        $resourcePath = '/properties/{property_id}/availability';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $token,
            'token', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            true // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $checkin,
            'checkin', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $checkout,
            'checkout', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $exclusion,
            'exclusion', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $filter,
            'filter', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $occupancy,
            'occupancy', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $rate_option,
            'rate_option', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $sales_channel,
            'sales_channel', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $sales_environment,
            'sales_environment', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);

        // header params
        if ($accept !== null) {
            $headerParams['Accept'] = ObjectSerializer::toHeaderValue($accept);
        }
        // header params
        if ($accept_encoding !== null) {
            $headerParams['Accept-Encoding'] = ObjectSerializer::toHeaderValue($accept_encoding);
        }
        // header params
        if ($user_agent !== null) {
            $headerParams['User-Agent'] = ObjectSerializer::toHeaderValue($user_agent);
        }
        // header params
        if ($customer_ip !== null) {
            $headerParams['Customer-Ip'] = ObjectSerializer::toHeaderValue($customer_ip);
        }
        // header params
        if ($customer_session_id !== null) {
            $headerParams['Customer-Session-Id'] = ObjectSerializer::toHeaderValue($customer_session_id);
        }
        // header params
        if ($test !== null) {
            $headerParams['Test'] = ObjectSerializer::toHeaderValue($test);
        }

        // path params
        if ($property_id !== null) {
            $resourcePath = str_replace(
                '{' . 'property_id' . '}',
                ObjectSerializer::toPathValue($property_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getAvailability
     *
     * Get property room rates and availability
     *
     * @param  string $accept Specifies the response format that the client would like to receive back. This must be &#x60;application/json&#x60;. (required)
     * @param  string $accept_encoding Specifies the response encoding that the client would like to receive back. This must be &#x60;gzip&#x60;. (required)
     * @param  string $user_agent The &#x60;User-Agent&#x60; header string from the customer&#39;s request, as captured by your integration. If you are building an application then the &#x60;User-Agent&#x60; value should be &#x60;{app name}/{app version}&#x60;. (required)
     * @param  string $checkin Check-in date, in ISO 8601 format (YYYY-MM-DD) (required)
     * @param  string $checkout Check-out date, in ISO 8601 format (YYYY-MM-DD). Availability can be searched up to 500 days in advance of this date. Total length of stay cannot exceed 28 nights. (required)
     * @param  string $currency Requested currency for the rates, in ISO 4217 format&lt;br&gt;&lt;br&gt; Currency Options: [https://developers.expediagroup.com/docs/rapid/resources/reference/currency-options](https://developers.expediagroup.com/docs/rapid/resources/reference/currency-options) (required)
     * @param  string $country_code The country code of the traveler&#39;s point of sale, in ISO 3166-1 alpha-2 format. This should represent the country where the shopping transaction is taking place.&lt;br&gt; For more information see: [https://www.iso.org/obp/ui/#search/code/](https://www.iso.org/obp/ui/#search/code/) (required)
     * @param  string $language Desired language for the response as a subset of BCP47 format that only uses hyphenated pairs of two-digit language and country codes. Use only ISO 639-1 alpha-2 language codes and ISO 3166-1 alpha-2 country codes. See [https://www.w3.org/International/articles/language-tags/](https://www.w3.org/International/articles/language-tags/)&lt;br&gt; Language Options: [https://developers.expediagroup.com/docs/rapid/resources/reference/language-options](https://developers.expediagroup.com/docs/rapid/resources/reference/language-options) (required)
     * @param  string[] $occupancy Defines the requested occupancy for a single room. Each room must have at least 1 adult occupant.&lt;br&gt; Format: &#x60;numberOfAdults[-firstChildAge[,nextChildAge]]&#x60;&lt;br&gt; To request multiple rooms (of the same type), include one instance of occupancy for each room requested. Up to 8 rooms may be requested or booked at once.&lt;br&gt; Examples: * 2 adults, one 9-year-old and one 4-year-old would be represented by &#x60;occupancy&#x3D;2-9,4&#x60;.&lt;br&gt; * A multi-room request to lodge an additional 2 adults would be represented by &#x60;occupancy&#x3D;2-9,4&amp;occupancy&#x3D;2&#x60; (required)
     * @param  string[] $property_id The ID of the property you want to search for. You can provide 1 to 250 property_id parameters. (required)
     * @param  float $rate_plan_count The number of rates to return per property. The rates with the best value will be returned, e.g. a rate_plan_count&#x3D;4 will return the best 4 rates, but the rates are not ordered from lowest to highest or vice versa in the response. Generally lowest rates will be prioritized.&lt;br&gt;&lt;br&gt; The value must be between 1 and 250. (required)
     * @param  string $sales_channel You must provide the sales channel for the display of rates. EPS dynamically provides the best content for optimal conversion on each sales channel. If you have a sales channel that is not currently supported in this list, please contact our support team.&lt;br&gt; * &#x60;website&#x60; - Standard website accessed from the customer&#39;s computer * &#x60;agent_tool&#x60; - Your own agent tool used by your call center or retail store agent * &#x60;mobile_app&#x60; - An application installed on a phone or tablet device * &#x60;mobile_web&#x60; - A web browser application on a phone or tablet device * &#x60;meta&#x60; - Rates will be passed to and displayed on a 3rd party comparison website * &#x60;cache&#x60; - Rates will be used to populate a local cache (required)
     * @param  string $sales_environment You must provide the sales environment in which rates will be sold. EPS dynamically provides the best content for optimal conversion. If you have a sales environment that is not currently supported in this list, please contact our support team.&lt;br&gt; * &#x60;hotel_package&#x60; - Use when selling the hotel with a transport product, e.g. flight &amp; hotel. * &#x60;hotel_only&#x60; - Use when selling the hotel as an individual product. * &#x60;loyalty&#x60; - Use when you are selling the hotel as part of a loyalty program and the price is converted to points. (required)
     * @param  string $customer_ip IP address of the customer, as captured by your integration.&lt;br&gt; Ensure your integration passes the customer&#39;s IP, not your own. This value helps determine their location and assign the correct payment gateway.&lt;br&gt; Also used for fraud recovery and other important analytics. (optional)
     * @param  string $customer_session_id Insert your own unique value for each user session, beginning with the first API call. Continue to pass the same value for each subsequent API call during the user&#39;s session, using a new value for every new customer session.&lt;br&gt; Including this value greatly eases EPS&#39;s internal debugging process for issues with partner requests, as it explicitly links together request paths for individual user&#39;s session. (optional)
     * @param  string $test Shop calls have a test header that can be used to return set responses with the following keywords:&lt;br&gt; * &#x60;standard&#x60; * &#x60;service_unavailable&#x60; * &#x60;unknown_internal_error&#x60; (optional)
     * @param  string[] $amenity_category Single amenity category. Send multiple instances of this parameter to request rates that match multiple amenity categories.&lt;br&gt; See the Amenity Categories section of the [Content Reference Lists](https://developers.expediagroup.com/docs/rapid/lodging/content/content-reference-lists) for a list of values. (optional)
     * @param  string[] $exclusion Single exclusion type. Send multiple instances of this parameter to request multiple exclusions.&lt;br&gt; * &#x60;refundable_damage_deposit&#x60; - Excludes rates with refundable damage deposits from the response. (optional)
     * @param  string[] $filter Single filter type. Send multiple instances of this parameter to request multiple filters.&lt;br&gt; * &#x60;refundable&#x60; - Filters results to only show fully refundable rates. * &#x60;expedia_collect&#x60; - Filters results to only show rates where payment is collected by Expedia at the time of booking. These properties can be eligible for payments via Expedia Affiliate Collect(EAC). * &#x60;property_collect&#x60; - Filters results to only show rates where payment is collected by the property after booking. This can include rates that require a deposit by the property, dependent upon the deposit policies. (optional)
     * @param  string[] $include Modify the response by including types of responses that are not provided by default.&lt;br&gt; * &#x60;unavailable_reason&#x60; - When a property is unavailable for an actionable reason, return a response with that reason - See [Unavailable Reason Codes](https://developers.expediagroup.com/docs/rapid/resources/reference/unavailable-reason-codes) for possible values. (optional)
     * @param  string[] $rate_option Request specific rate options for each property. Send multiple instances of this parameter to request multiple rate options. Accepted values:&lt;br&gt; * &#x60;member&#x60; - Return member rates for each property. This feature must be enabled and requires a user to be logged in to request these rates. * &#x60;net_rates&#x60; - Return net rates for each property. This feature must be enabled to request these rates. * &#x60;cross_sell&#x60; - Identify if the traffic is coming from a cross sell booking. Where the traveler has booked another service (flight, car, activities...) before hotel. (optional)
     * @param  string $travel_purpose This parameter is to specify the travel purpose of the booking. This may impact available rate plans, pricing, or tax calculations. * &#x60;leisure&#x60; * &#x60;business&#x60; (optional)
     * @param  string $billing_terms This parameter is to specify the terms of how a resulting booking should be billed. If this field is needed, the value for this will be provided to you separately. (optional)
     * @param  string $payment_terms This parameter is to specify what terms should be used when being paid for a resulting booking. If this field is needed, the value for this will be provided to you separately. (optional)
     * @param  string $partner_point_of_sale This parameter is to specify what point of sale is being used to shop and book. If this field is needed, the value for this will be provided to you separately. (optional)
     * @param  string $platform_name This parameter is to specify what platform is being used to shop and book. If this field is needed, the value for this will be provided to you separately. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getAvailability'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\Property[]|\OpenAPI\Client\Model\Error|\OpenAPI\Client\Model\Error|\OpenAPI\Client\Model\Error|\OpenAPI\Client\Model\Error|\OpenAPI\Client\Model\Error|\OpenAPI\Client\Model\Error|\OpenAPI\Client\Model\Error
     */
    public function getAvailability($accept, $accept_encoding, $user_agent, $checkin, $checkout, $currency, $country_code, $language, $occupancy, $property_id, $rate_plan_count, $sales_channel, $sales_environment, $customer_ip = null, $customer_session_id = null, $test = null, $amenity_category = null, $exclusion = null, $filter = null, $include = null, $rate_option = null, $travel_purpose = null, $billing_terms = null, $payment_terms = null, $partner_point_of_sale = null, $platform_name = null, string $contentType = self::contentTypes['getAvailability'][0])
    {
        list($response) = $this->getAvailabilityWithHttpInfo($accept, $accept_encoding, $user_agent, $checkin, $checkout, $currency, $country_code, $language, $occupancy, $property_id, $rate_plan_count, $sales_channel, $sales_environment, $customer_ip, $customer_session_id, $test, $amenity_category, $exclusion, $filter, $include, $rate_option, $travel_purpose, $billing_terms, $payment_terms, $partner_point_of_sale, $platform_name, $contentType);
        return $response;
    }

    /**
     * Operation getAvailabilityWithHttpInfo
     *
     * Get property room rates and availability
     *
     * @param  string $accept Specifies the response format that the client would like to receive back. This must be &#x60;application/json&#x60;. (required)
     * @param  string $accept_encoding Specifies the response encoding that the client would like to receive back. This must be &#x60;gzip&#x60;. (required)
     * @param  string $user_agent The &#x60;User-Agent&#x60; header string from the customer&#39;s request, as captured by your integration. If you are building an application then the &#x60;User-Agent&#x60; value should be &#x60;{app name}/{app version}&#x60;. (required)
     * @param  string $checkin Check-in date, in ISO 8601 format (YYYY-MM-DD) (required)
     * @param  string $checkout Check-out date, in ISO 8601 format (YYYY-MM-DD). Availability can be searched up to 500 days in advance of this date. Total length of stay cannot exceed 28 nights. (required)
     * @param  string $currency Requested currency for the rates, in ISO 4217 format&lt;br&gt;&lt;br&gt; Currency Options: [https://developers.expediagroup.com/docs/rapid/resources/reference/currency-options](https://developers.expediagroup.com/docs/rapid/resources/reference/currency-options) (required)
     * @param  string $country_code The country code of the traveler&#39;s point of sale, in ISO 3166-1 alpha-2 format. This should represent the country where the shopping transaction is taking place.&lt;br&gt; For more information see: [https://www.iso.org/obp/ui/#search/code/](https://www.iso.org/obp/ui/#search/code/) (required)
     * @param  string $language Desired language for the response as a subset of BCP47 format that only uses hyphenated pairs of two-digit language and country codes. Use only ISO 639-1 alpha-2 language codes and ISO 3166-1 alpha-2 country codes. See [https://www.w3.org/International/articles/language-tags/](https://www.w3.org/International/articles/language-tags/)&lt;br&gt; Language Options: [https://developers.expediagroup.com/docs/rapid/resources/reference/language-options](https://developers.expediagroup.com/docs/rapid/resources/reference/language-options) (required)
     * @param  string[] $occupancy Defines the requested occupancy for a single room. Each room must have at least 1 adult occupant.&lt;br&gt; Format: &#x60;numberOfAdults[-firstChildAge[,nextChildAge]]&#x60;&lt;br&gt; To request multiple rooms (of the same type), include one instance of occupancy for each room requested. Up to 8 rooms may be requested or booked at once.&lt;br&gt; Examples: * 2 adults, one 9-year-old and one 4-year-old would be represented by &#x60;occupancy&#x3D;2-9,4&#x60;.&lt;br&gt; * A multi-room request to lodge an additional 2 adults would be represented by &#x60;occupancy&#x3D;2-9,4&amp;occupancy&#x3D;2&#x60; (required)
     * @param  string[] $property_id The ID of the property you want to search for. You can provide 1 to 250 property_id parameters. (required)
     * @param  float $rate_plan_count The number of rates to return per property. The rates with the best value will be returned, e.g. a rate_plan_count&#x3D;4 will return the best 4 rates, but the rates are not ordered from lowest to highest or vice versa in the response. Generally lowest rates will be prioritized.&lt;br&gt;&lt;br&gt; The value must be between 1 and 250. (required)
     * @param  string $sales_channel You must provide the sales channel for the display of rates. EPS dynamically provides the best content for optimal conversion on each sales channel. If you have a sales channel that is not currently supported in this list, please contact our support team.&lt;br&gt; * &#x60;website&#x60; - Standard website accessed from the customer&#39;s computer * &#x60;agent_tool&#x60; - Your own agent tool used by your call center or retail store agent * &#x60;mobile_app&#x60; - An application installed on a phone or tablet device * &#x60;mobile_web&#x60; - A web browser application on a phone or tablet device * &#x60;meta&#x60; - Rates will be passed to and displayed on a 3rd party comparison website * &#x60;cache&#x60; - Rates will be used to populate a local cache (required)
     * @param  string $sales_environment You must provide the sales environment in which rates will be sold. EPS dynamically provides the best content for optimal conversion. If you have a sales environment that is not currently supported in this list, please contact our support team.&lt;br&gt; * &#x60;hotel_package&#x60; - Use when selling the hotel with a transport product, e.g. flight &amp; hotel. * &#x60;hotel_only&#x60; - Use when selling the hotel as an individual product. * &#x60;loyalty&#x60; - Use when you are selling the hotel as part of a loyalty program and the price is converted to points. (required)
     * @param  string $customer_ip IP address of the customer, as captured by your integration.&lt;br&gt; Ensure your integration passes the customer&#39;s IP, not your own. This value helps determine their location and assign the correct payment gateway.&lt;br&gt; Also used for fraud recovery and other important analytics. (optional)
     * @param  string $customer_session_id Insert your own unique value for each user session, beginning with the first API call. Continue to pass the same value for each subsequent API call during the user&#39;s session, using a new value for every new customer session.&lt;br&gt; Including this value greatly eases EPS&#39;s internal debugging process for issues with partner requests, as it explicitly links together request paths for individual user&#39;s session. (optional)
     * @param  string $test Shop calls have a test header that can be used to return set responses with the following keywords:&lt;br&gt; * &#x60;standard&#x60; * &#x60;service_unavailable&#x60; * &#x60;unknown_internal_error&#x60; (optional)
     * @param  string[] $amenity_category Single amenity category. Send multiple instances of this parameter to request rates that match multiple amenity categories.&lt;br&gt; See the Amenity Categories section of the [Content Reference Lists](https://developers.expediagroup.com/docs/rapid/lodging/content/content-reference-lists) for a list of values. (optional)
     * @param  string[] $exclusion Single exclusion type. Send multiple instances of this parameter to request multiple exclusions.&lt;br&gt; * &#x60;refundable_damage_deposit&#x60; - Excludes rates with refundable damage deposits from the response. (optional)
     * @param  string[] $filter Single filter type. Send multiple instances of this parameter to request multiple filters.&lt;br&gt; * &#x60;refundable&#x60; - Filters results to only show fully refundable rates. * &#x60;expedia_collect&#x60; - Filters results to only show rates where payment is collected by Expedia at the time of booking. These properties can be eligible for payments via Expedia Affiliate Collect(EAC). * &#x60;property_collect&#x60; - Filters results to only show rates where payment is collected by the property after booking. This can include rates that require a deposit by the property, dependent upon the deposit policies. (optional)
     * @param  string[] $include Modify the response by including types of responses that are not provided by default.&lt;br&gt; * &#x60;unavailable_reason&#x60; - When a property is unavailable for an actionable reason, return a response with that reason - See [Unavailable Reason Codes](https://developers.expediagroup.com/docs/rapid/resources/reference/unavailable-reason-codes) for possible values. (optional)
     * @param  string[] $rate_option Request specific rate options for each property. Send multiple instances of this parameter to request multiple rate options. Accepted values:&lt;br&gt; * &#x60;member&#x60; - Return member rates for each property. This feature must be enabled and requires a user to be logged in to request these rates. * &#x60;net_rates&#x60; - Return net rates for each property. This feature must be enabled to request these rates. * &#x60;cross_sell&#x60; - Identify if the traffic is coming from a cross sell booking. Where the traveler has booked another service (flight, car, activities...) before hotel. (optional)
     * @param  string $travel_purpose This parameter is to specify the travel purpose of the booking. This may impact available rate plans, pricing, or tax calculations. * &#x60;leisure&#x60; * &#x60;business&#x60; (optional)
     * @param  string $billing_terms This parameter is to specify the terms of how a resulting booking should be billed. If this field is needed, the value for this will be provided to you separately. (optional)
     * @param  string $payment_terms This parameter is to specify what terms should be used when being paid for a resulting booking. If this field is needed, the value for this will be provided to you separately. (optional)
     * @param  string $partner_point_of_sale This parameter is to specify what point of sale is being used to shop and book. If this field is needed, the value for this will be provided to you separately. (optional)
     * @param  string $platform_name This parameter is to specify what platform is being used to shop and book. If this field is needed, the value for this will be provided to you separately. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getAvailability'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\Property[]|\OpenAPI\Client\Model\Error|\OpenAPI\Client\Model\Error|\OpenAPI\Client\Model\Error|\OpenAPI\Client\Model\Error|\OpenAPI\Client\Model\Error|\OpenAPI\Client\Model\Error|\OpenAPI\Client\Model\Error, HTTP status code, HTTP response headers (array of strings)
     */
    public function getAvailabilityWithHttpInfo($accept, $accept_encoding, $user_agent, $checkin, $checkout, $currency, $country_code, $language, $occupancy, $property_id, $rate_plan_count, $sales_channel, $sales_environment, $customer_ip = null, $customer_session_id = null, $test = null, $amenity_category = null, $exclusion = null, $filter = null, $include = null, $rate_option = null, $travel_purpose = null, $billing_terms = null, $payment_terms = null, $partner_point_of_sale = null, $platform_name = null, string $contentType = self::contentTypes['getAvailability'][0])
    {
        $request = $this->getAvailabilityRequest($accept, $accept_encoding, $user_agent, $checkin, $checkout, $currency, $country_code, $language, $occupancy, $property_id, $rate_plan_count, $sales_channel, $sales_environment, $customer_ip, $customer_session_id, $test, $amenity_category, $exclusion, $filter, $include, $rate_option, $travel_purpose, $billing_terms, $payment_terms, $partner_point_of_sale, $platform_name, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\Property[]' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\Property[]' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\Property[]', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 400:
                    if ('\OpenAPI\Client\Model\Error' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\Error' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\Error', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 401:
                    if ('\OpenAPI\Client\Model\Error' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\Error' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\Error', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 403:
                    if ('\OpenAPI\Client\Model\Error' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\Error' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\Error', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 426:
                    if ('\OpenAPI\Client\Model\Error' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\Error' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\Error', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 429:
                    if ('\OpenAPI\Client\Model\Error' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\Error' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\Error', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 500:
                    if ('\OpenAPI\Client\Model\Error' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\Error' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\Error', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 503:
                    if ('\OpenAPI\Client\Model\Error' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\Error' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\Error', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\Property[]';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\Property[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\Error',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 401:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\Error',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 403:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\Error',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 426:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\Error',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 429:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\Error',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 500:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\Error',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 503:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\Error',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getAvailabilityAsync
     *
     * Get property room rates and availability
     *
     * @param  string $accept Specifies the response format that the client would like to receive back. This must be &#x60;application/json&#x60;. (required)
     * @param  string $accept_encoding Specifies the response encoding that the client would like to receive back. This must be &#x60;gzip&#x60;. (required)
     * @param  string $user_agent The &#x60;User-Agent&#x60; header string from the customer&#39;s request, as captured by your integration. If you are building an application then the &#x60;User-Agent&#x60; value should be &#x60;{app name}/{app version}&#x60;. (required)
     * @param  string $checkin Check-in date, in ISO 8601 format (YYYY-MM-DD) (required)
     * @param  string $checkout Check-out date, in ISO 8601 format (YYYY-MM-DD). Availability can be searched up to 500 days in advance of this date. Total length of stay cannot exceed 28 nights. (required)
     * @param  string $currency Requested currency for the rates, in ISO 4217 format&lt;br&gt;&lt;br&gt; Currency Options: [https://developers.expediagroup.com/docs/rapid/resources/reference/currency-options](https://developers.expediagroup.com/docs/rapid/resources/reference/currency-options) (required)
     * @param  string $country_code The country code of the traveler&#39;s point of sale, in ISO 3166-1 alpha-2 format. This should represent the country where the shopping transaction is taking place.&lt;br&gt; For more information see: [https://www.iso.org/obp/ui/#search/code/](https://www.iso.org/obp/ui/#search/code/) (required)
     * @param  string $language Desired language for the response as a subset of BCP47 format that only uses hyphenated pairs of two-digit language and country codes. Use only ISO 639-1 alpha-2 language codes and ISO 3166-1 alpha-2 country codes. See [https://www.w3.org/International/articles/language-tags/](https://www.w3.org/International/articles/language-tags/)&lt;br&gt; Language Options: [https://developers.expediagroup.com/docs/rapid/resources/reference/language-options](https://developers.expediagroup.com/docs/rapid/resources/reference/language-options) (required)
     * @param  string[] $occupancy Defines the requested occupancy for a single room. Each room must have at least 1 adult occupant.&lt;br&gt; Format: &#x60;numberOfAdults[-firstChildAge[,nextChildAge]]&#x60;&lt;br&gt; To request multiple rooms (of the same type), include one instance of occupancy for each room requested. Up to 8 rooms may be requested or booked at once.&lt;br&gt; Examples: * 2 adults, one 9-year-old and one 4-year-old would be represented by &#x60;occupancy&#x3D;2-9,4&#x60;.&lt;br&gt; * A multi-room request to lodge an additional 2 adults would be represented by &#x60;occupancy&#x3D;2-9,4&amp;occupancy&#x3D;2&#x60; (required)
     * @param  string[] $property_id The ID of the property you want to search for. You can provide 1 to 250 property_id parameters. (required)
     * @param  float $rate_plan_count The number of rates to return per property. The rates with the best value will be returned, e.g. a rate_plan_count&#x3D;4 will return the best 4 rates, but the rates are not ordered from lowest to highest or vice versa in the response. Generally lowest rates will be prioritized.&lt;br&gt;&lt;br&gt; The value must be between 1 and 250. (required)
     * @param  string $sales_channel You must provide the sales channel for the display of rates. EPS dynamically provides the best content for optimal conversion on each sales channel. If you have a sales channel that is not currently supported in this list, please contact our support team.&lt;br&gt; * &#x60;website&#x60; - Standard website accessed from the customer&#39;s computer * &#x60;agent_tool&#x60; - Your own agent tool used by your call center or retail store agent * &#x60;mobile_app&#x60; - An application installed on a phone or tablet device * &#x60;mobile_web&#x60; - A web browser application on a phone or tablet device * &#x60;meta&#x60; - Rates will be passed to and displayed on a 3rd party comparison website * &#x60;cache&#x60; - Rates will be used to populate a local cache (required)
     * @param  string $sales_environment You must provide the sales environment in which rates will be sold. EPS dynamically provides the best content for optimal conversion. If you have a sales environment that is not currently supported in this list, please contact our support team.&lt;br&gt; * &#x60;hotel_package&#x60; - Use when selling the hotel with a transport product, e.g. flight &amp; hotel. * &#x60;hotel_only&#x60; - Use when selling the hotel as an individual product. * &#x60;loyalty&#x60; - Use when you are selling the hotel as part of a loyalty program and the price is converted to points. (required)
     * @param  string $customer_ip IP address of the customer, as captured by your integration.&lt;br&gt; Ensure your integration passes the customer&#39;s IP, not your own. This value helps determine their location and assign the correct payment gateway.&lt;br&gt; Also used for fraud recovery and other important analytics. (optional)
     * @param  string $customer_session_id Insert your own unique value for each user session, beginning with the first API call. Continue to pass the same value for each subsequent API call during the user&#39;s session, using a new value for every new customer session.&lt;br&gt; Including this value greatly eases EPS&#39;s internal debugging process for issues with partner requests, as it explicitly links together request paths for individual user&#39;s session. (optional)
     * @param  string $test Shop calls have a test header that can be used to return set responses with the following keywords:&lt;br&gt; * &#x60;standard&#x60; * &#x60;service_unavailable&#x60; * &#x60;unknown_internal_error&#x60; (optional)
     * @param  string[] $amenity_category Single amenity category. Send multiple instances of this parameter to request rates that match multiple amenity categories.&lt;br&gt; See the Amenity Categories section of the [Content Reference Lists](https://developers.expediagroup.com/docs/rapid/lodging/content/content-reference-lists) for a list of values. (optional)
     * @param  string[] $exclusion Single exclusion type. Send multiple instances of this parameter to request multiple exclusions.&lt;br&gt; * &#x60;refundable_damage_deposit&#x60; - Excludes rates with refundable damage deposits from the response. (optional)
     * @param  string[] $filter Single filter type. Send multiple instances of this parameter to request multiple filters.&lt;br&gt; * &#x60;refundable&#x60; - Filters results to only show fully refundable rates. * &#x60;expedia_collect&#x60; - Filters results to only show rates where payment is collected by Expedia at the time of booking. These properties can be eligible for payments via Expedia Affiliate Collect(EAC). * &#x60;property_collect&#x60; - Filters results to only show rates where payment is collected by the property after booking. This can include rates that require a deposit by the property, dependent upon the deposit policies. (optional)
     * @param  string[] $include Modify the response by including types of responses that are not provided by default.&lt;br&gt; * &#x60;unavailable_reason&#x60; - When a property is unavailable for an actionable reason, return a response with that reason - See [Unavailable Reason Codes](https://developers.expediagroup.com/docs/rapid/resources/reference/unavailable-reason-codes) for possible values. (optional)
     * @param  string[] $rate_option Request specific rate options for each property. Send multiple instances of this parameter to request multiple rate options. Accepted values:&lt;br&gt; * &#x60;member&#x60; - Return member rates for each property. This feature must be enabled and requires a user to be logged in to request these rates. * &#x60;net_rates&#x60; - Return net rates for each property. This feature must be enabled to request these rates. * &#x60;cross_sell&#x60; - Identify if the traffic is coming from a cross sell booking. Where the traveler has booked another service (flight, car, activities...) before hotel. (optional)
     * @param  string $travel_purpose This parameter is to specify the travel purpose of the booking. This may impact available rate plans, pricing, or tax calculations. * &#x60;leisure&#x60; * &#x60;business&#x60; (optional)
     * @param  string $billing_terms This parameter is to specify the terms of how a resulting booking should be billed. If this field is needed, the value for this will be provided to you separately. (optional)
     * @param  string $payment_terms This parameter is to specify what terms should be used when being paid for a resulting booking. If this field is needed, the value for this will be provided to you separately. (optional)
     * @param  string $partner_point_of_sale This parameter is to specify what point of sale is being used to shop and book. If this field is needed, the value for this will be provided to you separately. (optional)
     * @param  string $platform_name This parameter is to specify what platform is being used to shop and book. If this field is needed, the value for this will be provided to you separately. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getAvailability'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getAvailabilityAsync($accept, $accept_encoding, $user_agent, $checkin, $checkout, $currency, $country_code, $language, $occupancy, $property_id, $rate_plan_count, $sales_channel, $sales_environment, $customer_ip = null, $customer_session_id = null, $test = null, $amenity_category = null, $exclusion = null, $filter = null, $include = null, $rate_option = null, $travel_purpose = null, $billing_terms = null, $payment_terms = null, $partner_point_of_sale = null, $platform_name = null, string $contentType = self::contentTypes['getAvailability'][0])
    {
        return $this->getAvailabilityAsyncWithHttpInfo($accept, $accept_encoding, $user_agent, $checkin, $checkout, $currency, $country_code, $language, $occupancy, $property_id, $rate_plan_count, $sales_channel, $sales_environment, $customer_ip, $customer_session_id, $test, $amenity_category, $exclusion, $filter, $include, $rate_option, $travel_purpose, $billing_terms, $payment_terms, $partner_point_of_sale, $platform_name, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getAvailabilityAsyncWithHttpInfo
     *
     * Get property room rates and availability
     *
     * @param  string $accept Specifies the response format that the client would like to receive back. This must be &#x60;application/json&#x60;. (required)
     * @param  string $accept_encoding Specifies the response encoding that the client would like to receive back. This must be &#x60;gzip&#x60;. (required)
     * @param  string $user_agent The &#x60;User-Agent&#x60; header string from the customer&#39;s request, as captured by your integration. If you are building an application then the &#x60;User-Agent&#x60; value should be &#x60;{app name}/{app version}&#x60;. (required)
     * @param  string $checkin Check-in date, in ISO 8601 format (YYYY-MM-DD) (required)
     * @param  string $checkout Check-out date, in ISO 8601 format (YYYY-MM-DD). Availability can be searched up to 500 days in advance of this date. Total length of stay cannot exceed 28 nights. (required)
     * @param  string $currency Requested currency for the rates, in ISO 4217 format&lt;br&gt;&lt;br&gt; Currency Options: [https://developers.expediagroup.com/docs/rapid/resources/reference/currency-options](https://developers.expediagroup.com/docs/rapid/resources/reference/currency-options) (required)
     * @param  string $country_code The country code of the traveler&#39;s point of sale, in ISO 3166-1 alpha-2 format. This should represent the country where the shopping transaction is taking place.&lt;br&gt; For more information see: [https://www.iso.org/obp/ui/#search/code/](https://www.iso.org/obp/ui/#search/code/) (required)
     * @param  string $language Desired language for the response as a subset of BCP47 format that only uses hyphenated pairs of two-digit language and country codes. Use only ISO 639-1 alpha-2 language codes and ISO 3166-1 alpha-2 country codes. See [https://www.w3.org/International/articles/language-tags/](https://www.w3.org/International/articles/language-tags/)&lt;br&gt; Language Options: [https://developers.expediagroup.com/docs/rapid/resources/reference/language-options](https://developers.expediagroup.com/docs/rapid/resources/reference/language-options) (required)
     * @param  string[] $occupancy Defines the requested occupancy for a single room. Each room must have at least 1 adult occupant.&lt;br&gt; Format: &#x60;numberOfAdults[-firstChildAge[,nextChildAge]]&#x60;&lt;br&gt; To request multiple rooms (of the same type), include one instance of occupancy for each room requested. Up to 8 rooms may be requested or booked at once.&lt;br&gt; Examples: * 2 adults, one 9-year-old and one 4-year-old would be represented by &#x60;occupancy&#x3D;2-9,4&#x60;.&lt;br&gt; * A multi-room request to lodge an additional 2 adults would be represented by &#x60;occupancy&#x3D;2-9,4&amp;occupancy&#x3D;2&#x60; (required)
     * @param  string[] $property_id The ID of the property you want to search for. You can provide 1 to 250 property_id parameters. (required)
     * @param  float $rate_plan_count The number of rates to return per property. The rates with the best value will be returned, e.g. a rate_plan_count&#x3D;4 will return the best 4 rates, but the rates are not ordered from lowest to highest or vice versa in the response. Generally lowest rates will be prioritized.&lt;br&gt;&lt;br&gt; The value must be between 1 and 250. (required)
     * @param  string $sales_channel You must provide the sales channel for the display of rates. EPS dynamically provides the best content for optimal conversion on each sales channel. If you have a sales channel that is not currently supported in this list, please contact our support team.&lt;br&gt; * &#x60;website&#x60; - Standard website accessed from the customer&#39;s computer * &#x60;agent_tool&#x60; - Your own agent tool used by your call center or retail store agent * &#x60;mobile_app&#x60; - An application installed on a phone or tablet device * &#x60;mobile_web&#x60; - A web browser application on a phone or tablet device * &#x60;meta&#x60; - Rates will be passed to and displayed on a 3rd party comparison website * &#x60;cache&#x60; - Rates will be used to populate a local cache (required)
     * @param  string $sales_environment You must provide the sales environment in which rates will be sold. EPS dynamically provides the best content for optimal conversion. If you have a sales environment that is not currently supported in this list, please contact our support team.&lt;br&gt; * &#x60;hotel_package&#x60; - Use when selling the hotel with a transport product, e.g. flight &amp; hotel. * &#x60;hotel_only&#x60; - Use when selling the hotel as an individual product. * &#x60;loyalty&#x60; - Use when you are selling the hotel as part of a loyalty program and the price is converted to points. (required)
     * @param  string $customer_ip IP address of the customer, as captured by your integration.&lt;br&gt; Ensure your integration passes the customer&#39;s IP, not your own. This value helps determine their location and assign the correct payment gateway.&lt;br&gt; Also used for fraud recovery and other important analytics. (optional)
     * @param  string $customer_session_id Insert your own unique value for each user session, beginning with the first API call. Continue to pass the same value for each subsequent API call during the user&#39;s session, using a new value for every new customer session.&lt;br&gt; Including this value greatly eases EPS&#39;s internal debugging process for issues with partner requests, as it explicitly links together request paths for individual user&#39;s session. (optional)
     * @param  string $test Shop calls have a test header that can be used to return set responses with the following keywords:&lt;br&gt; * &#x60;standard&#x60; * &#x60;service_unavailable&#x60; * &#x60;unknown_internal_error&#x60; (optional)
     * @param  string[] $amenity_category Single amenity category. Send multiple instances of this parameter to request rates that match multiple amenity categories.&lt;br&gt; See the Amenity Categories section of the [Content Reference Lists](https://developers.expediagroup.com/docs/rapid/lodging/content/content-reference-lists) for a list of values. (optional)
     * @param  string[] $exclusion Single exclusion type. Send multiple instances of this parameter to request multiple exclusions.&lt;br&gt; * &#x60;refundable_damage_deposit&#x60; - Excludes rates with refundable damage deposits from the response. (optional)
     * @param  string[] $filter Single filter type. Send multiple instances of this parameter to request multiple filters.&lt;br&gt; * &#x60;refundable&#x60; - Filters results to only show fully refundable rates. * &#x60;expedia_collect&#x60; - Filters results to only show rates where payment is collected by Expedia at the time of booking. These properties can be eligible for payments via Expedia Affiliate Collect(EAC). * &#x60;property_collect&#x60; - Filters results to only show rates where payment is collected by the property after booking. This can include rates that require a deposit by the property, dependent upon the deposit policies. (optional)
     * @param  string[] $include Modify the response by including types of responses that are not provided by default.&lt;br&gt; * &#x60;unavailable_reason&#x60; - When a property is unavailable for an actionable reason, return a response with that reason - See [Unavailable Reason Codes](https://developers.expediagroup.com/docs/rapid/resources/reference/unavailable-reason-codes) for possible values. (optional)
     * @param  string[] $rate_option Request specific rate options for each property. Send multiple instances of this parameter to request multiple rate options. Accepted values:&lt;br&gt; * &#x60;member&#x60; - Return member rates for each property. This feature must be enabled and requires a user to be logged in to request these rates. * &#x60;net_rates&#x60; - Return net rates for each property. This feature must be enabled to request these rates. * &#x60;cross_sell&#x60; - Identify if the traffic is coming from a cross sell booking. Where the traveler has booked another service (flight, car, activities...) before hotel. (optional)
     * @param  string $travel_purpose This parameter is to specify the travel purpose of the booking. This may impact available rate plans, pricing, or tax calculations. * &#x60;leisure&#x60; * &#x60;business&#x60; (optional)
     * @param  string $billing_terms This parameter is to specify the terms of how a resulting booking should be billed. If this field is needed, the value for this will be provided to you separately. (optional)
     * @param  string $payment_terms This parameter is to specify what terms should be used when being paid for a resulting booking. If this field is needed, the value for this will be provided to you separately. (optional)
     * @param  string $partner_point_of_sale This parameter is to specify what point of sale is being used to shop and book. If this field is needed, the value for this will be provided to you separately. (optional)
     * @param  string $platform_name This parameter is to specify what platform is being used to shop and book. If this field is needed, the value for this will be provided to you separately. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getAvailability'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getAvailabilityAsyncWithHttpInfo($accept, $accept_encoding, $user_agent, $checkin, $checkout, $currency, $country_code, $language, $occupancy, $property_id, $rate_plan_count, $sales_channel, $sales_environment, $customer_ip = null, $customer_session_id = null, $test = null, $amenity_category = null, $exclusion = null, $filter = null, $include = null, $rate_option = null, $travel_purpose = null, $billing_terms = null, $payment_terms = null, $partner_point_of_sale = null, $platform_name = null, string $contentType = self::contentTypes['getAvailability'][0])
    {
        $returnType = '\OpenAPI\Client\Model\Property[]';
        $request = $this->getAvailabilityRequest($accept, $accept_encoding, $user_agent, $checkin, $checkout, $currency, $country_code, $language, $occupancy, $property_id, $rate_plan_count, $sales_channel, $sales_environment, $customer_ip, $customer_session_id, $test, $amenity_category, $exclusion, $filter, $include, $rate_option, $travel_purpose, $billing_terms, $payment_terms, $partner_point_of_sale, $platform_name, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getAvailability'
     *
     * @param  string $accept Specifies the response format that the client would like to receive back. This must be &#x60;application/json&#x60;. (required)
     * @param  string $accept_encoding Specifies the response encoding that the client would like to receive back. This must be &#x60;gzip&#x60;. (required)
     * @param  string $user_agent The &#x60;User-Agent&#x60; header string from the customer&#39;s request, as captured by your integration. If you are building an application then the &#x60;User-Agent&#x60; value should be &#x60;{app name}/{app version}&#x60;. (required)
     * @param  string $checkin Check-in date, in ISO 8601 format (YYYY-MM-DD) (required)
     * @param  string $checkout Check-out date, in ISO 8601 format (YYYY-MM-DD). Availability can be searched up to 500 days in advance of this date. Total length of stay cannot exceed 28 nights. (required)
     * @param  string $currency Requested currency for the rates, in ISO 4217 format&lt;br&gt;&lt;br&gt; Currency Options: [https://developers.expediagroup.com/docs/rapid/resources/reference/currency-options](https://developers.expediagroup.com/docs/rapid/resources/reference/currency-options) (required)
     * @param  string $country_code The country code of the traveler&#39;s point of sale, in ISO 3166-1 alpha-2 format. This should represent the country where the shopping transaction is taking place.&lt;br&gt; For more information see: [https://www.iso.org/obp/ui/#search/code/](https://www.iso.org/obp/ui/#search/code/) (required)
     * @param  string $language Desired language for the response as a subset of BCP47 format that only uses hyphenated pairs of two-digit language and country codes. Use only ISO 639-1 alpha-2 language codes and ISO 3166-1 alpha-2 country codes. See [https://www.w3.org/International/articles/language-tags/](https://www.w3.org/International/articles/language-tags/)&lt;br&gt; Language Options: [https://developers.expediagroup.com/docs/rapid/resources/reference/language-options](https://developers.expediagroup.com/docs/rapid/resources/reference/language-options) (required)
     * @param  string[] $occupancy Defines the requested occupancy for a single room. Each room must have at least 1 adult occupant.&lt;br&gt; Format: &#x60;numberOfAdults[-firstChildAge[,nextChildAge]]&#x60;&lt;br&gt; To request multiple rooms (of the same type), include one instance of occupancy for each room requested. Up to 8 rooms may be requested or booked at once.&lt;br&gt; Examples: * 2 adults, one 9-year-old and one 4-year-old would be represented by &#x60;occupancy&#x3D;2-9,4&#x60;.&lt;br&gt; * A multi-room request to lodge an additional 2 adults would be represented by &#x60;occupancy&#x3D;2-9,4&amp;occupancy&#x3D;2&#x60; (required)
     * @param  string[] $property_id The ID of the property you want to search for. You can provide 1 to 250 property_id parameters. (required)
     * @param  float $rate_plan_count The number of rates to return per property. The rates with the best value will be returned, e.g. a rate_plan_count&#x3D;4 will return the best 4 rates, but the rates are not ordered from lowest to highest or vice versa in the response. Generally lowest rates will be prioritized.&lt;br&gt;&lt;br&gt; The value must be between 1 and 250. (required)
     * @param  string $sales_channel You must provide the sales channel for the display of rates. EPS dynamically provides the best content for optimal conversion on each sales channel. If you have a sales channel that is not currently supported in this list, please contact our support team.&lt;br&gt; * &#x60;website&#x60; - Standard website accessed from the customer&#39;s computer * &#x60;agent_tool&#x60; - Your own agent tool used by your call center or retail store agent * &#x60;mobile_app&#x60; - An application installed on a phone or tablet device * &#x60;mobile_web&#x60; - A web browser application on a phone or tablet device * &#x60;meta&#x60; - Rates will be passed to and displayed on a 3rd party comparison website * &#x60;cache&#x60; - Rates will be used to populate a local cache (required)
     * @param  string $sales_environment You must provide the sales environment in which rates will be sold. EPS dynamically provides the best content for optimal conversion. If you have a sales environment that is not currently supported in this list, please contact our support team.&lt;br&gt; * &#x60;hotel_package&#x60; - Use when selling the hotel with a transport product, e.g. flight &amp; hotel. * &#x60;hotel_only&#x60; - Use when selling the hotel as an individual product. * &#x60;loyalty&#x60; - Use when you are selling the hotel as part of a loyalty program and the price is converted to points. (required)
     * @param  string $customer_ip IP address of the customer, as captured by your integration.&lt;br&gt; Ensure your integration passes the customer&#39;s IP, not your own. This value helps determine their location and assign the correct payment gateway.&lt;br&gt; Also used for fraud recovery and other important analytics. (optional)
     * @param  string $customer_session_id Insert your own unique value for each user session, beginning with the first API call. Continue to pass the same value for each subsequent API call during the user&#39;s session, using a new value for every new customer session.&lt;br&gt; Including this value greatly eases EPS&#39;s internal debugging process for issues with partner requests, as it explicitly links together request paths for individual user&#39;s session. (optional)
     * @param  string $test Shop calls have a test header that can be used to return set responses with the following keywords:&lt;br&gt; * &#x60;standard&#x60; * &#x60;service_unavailable&#x60; * &#x60;unknown_internal_error&#x60; (optional)
     * @param  string[] $amenity_category Single amenity category. Send multiple instances of this parameter to request rates that match multiple amenity categories.&lt;br&gt; See the Amenity Categories section of the [Content Reference Lists](https://developers.expediagroup.com/docs/rapid/lodging/content/content-reference-lists) for a list of values. (optional)
     * @param  string[] $exclusion Single exclusion type. Send multiple instances of this parameter to request multiple exclusions.&lt;br&gt; * &#x60;refundable_damage_deposit&#x60; - Excludes rates with refundable damage deposits from the response. (optional)
     * @param  string[] $filter Single filter type. Send multiple instances of this parameter to request multiple filters.&lt;br&gt; * &#x60;refundable&#x60; - Filters results to only show fully refundable rates. * &#x60;expedia_collect&#x60; - Filters results to only show rates where payment is collected by Expedia at the time of booking. These properties can be eligible for payments via Expedia Affiliate Collect(EAC). * &#x60;property_collect&#x60; - Filters results to only show rates where payment is collected by the property after booking. This can include rates that require a deposit by the property, dependent upon the deposit policies. (optional)
     * @param  string[] $include Modify the response by including types of responses that are not provided by default.&lt;br&gt; * &#x60;unavailable_reason&#x60; - When a property is unavailable for an actionable reason, return a response with that reason - See [Unavailable Reason Codes](https://developers.expediagroup.com/docs/rapid/resources/reference/unavailable-reason-codes) for possible values. (optional)
     * @param  string[] $rate_option Request specific rate options for each property. Send multiple instances of this parameter to request multiple rate options. Accepted values:&lt;br&gt; * &#x60;member&#x60; - Return member rates for each property. This feature must be enabled and requires a user to be logged in to request these rates. * &#x60;net_rates&#x60; - Return net rates for each property. This feature must be enabled to request these rates. * &#x60;cross_sell&#x60; - Identify if the traffic is coming from a cross sell booking. Where the traveler has booked another service (flight, car, activities...) before hotel. (optional)
     * @param  string $travel_purpose This parameter is to specify the travel purpose of the booking. This may impact available rate plans, pricing, or tax calculations. * &#x60;leisure&#x60; * &#x60;business&#x60; (optional)
     * @param  string $billing_terms This parameter is to specify the terms of how a resulting booking should be billed. If this field is needed, the value for this will be provided to you separately. (optional)
     * @param  string $payment_terms This parameter is to specify what terms should be used when being paid for a resulting booking. If this field is needed, the value for this will be provided to you separately. (optional)
     * @param  string $partner_point_of_sale This parameter is to specify what point of sale is being used to shop and book. If this field is needed, the value for this will be provided to you separately. (optional)
     * @param  string $platform_name This parameter is to specify what platform is being used to shop and book. If this field is needed, the value for this will be provided to you separately. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getAvailability'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function getAvailabilityRequest($accept, $accept_encoding, $user_agent, $checkin, $checkout, $currency, $country_code, $language, $occupancy, $property_id, $rate_plan_count, $sales_channel, $sales_environment, $customer_ip = null, $customer_session_id = null, $test = null, $amenity_category = null, $exclusion = null, $filter = null, $include = null, $rate_option = null, $travel_purpose = null, $billing_terms = null, $payment_terms = null, $partner_point_of_sale = null, $platform_name = null, string $contentType = self::contentTypes['getAvailability'][0])
    {

        // verify the required parameter 'accept' is set
        if ($accept === null || (is_array($accept) && count($accept) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $accept when calling getAvailability'
            );
        }

        // verify the required parameter 'accept_encoding' is set
        if ($accept_encoding === null || (is_array($accept_encoding) && count($accept_encoding) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $accept_encoding when calling getAvailability'
            );
        }

        // verify the required parameter 'user_agent' is set
        if ($user_agent === null || (is_array($user_agent) && count($user_agent) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $user_agent when calling getAvailability'
            );
        }

        // verify the required parameter 'checkin' is set
        if ($checkin === null || (is_array($checkin) && count($checkin) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $checkin when calling getAvailability'
            );
        }

        // verify the required parameter 'checkout' is set
        if ($checkout === null || (is_array($checkout) && count($checkout) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $checkout when calling getAvailability'
            );
        }

        // verify the required parameter 'currency' is set
        if ($currency === null || (is_array($currency) && count($currency) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $currency when calling getAvailability'
            );
        }

        // verify the required parameter 'country_code' is set
        if ($country_code === null || (is_array($country_code) && count($country_code) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $country_code when calling getAvailability'
            );
        }

        // verify the required parameter 'language' is set
        if ($language === null || (is_array($language) && count($language) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $language when calling getAvailability'
            );
        }

        // verify the required parameter 'occupancy' is set
        if ($occupancy === null || (is_array($occupancy) && count($occupancy) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $occupancy when calling getAvailability'
            );
        }

        // verify the required parameter 'property_id' is set
        if ($property_id === null || (is_array($property_id) && count($property_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $property_id when calling getAvailability'
            );
        }

        // verify the required parameter 'rate_plan_count' is set
        if ($rate_plan_count === null || (is_array($rate_plan_count) && count($rate_plan_count) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $rate_plan_count when calling getAvailability'
            );
        }

        // verify the required parameter 'sales_channel' is set
        if ($sales_channel === null || (is_array($sales_channel) && count($sales_channel) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $sales_channel when calling getAvailability'
            );
        }

        // verify the required parameter 'sales_environment' is set
        if ($sales_environment === null || (is_array($sales_environment) && count($sales_environment) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $sales_environment when calling getAvailability'
            );
        }















        $resourcePath = '/properties/availability';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $checkin,
            'checkin', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            true // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $checkout,
            'checkout', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            true // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $currency,
            'currency', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            true // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $country_code,
            'country_code', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            true // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $language,
            'language', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            true // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $occupancy,
            'occupancy', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            true // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $property_id,
            'property_id', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            true // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $rate_plan_count,
            'rate_plan_count', // param base name
            'number', // openApiType
            'form', // style
            true, // explode
            true // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $sales_channel,
            'sales_channel', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            true // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $sales_environment,
            'sales_environment', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            true // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $amenity_category,
            'amenity_category', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $exclusion,
            'exclusion', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $filter,
            'filter', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $include,
            'include', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $rate_option,
            'rate_option', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $travel_purpose,
            'travel_purpose', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $billing_terms,
            'billing_terms', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $payment_terms,
            'payment_terms', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $partner_point_of_sale,
            'partner_point_of_sale', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $platform_name,
            'platform_name', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);

        // header params
        if ($accept !== null) {
            $headerParams['Accept'] = ObjectSerializer::toHeaderValue($accept);
        }
        // header params
        if ($accept_encoding !== null) {
            $headerParams['Accept-Encoding'] = ObjectSerializer::toHeaderValue($accept_encoding);
        }
        // header params
        if ($user_agent !== null) {
            $headerParams['User-Agent'] = ObjectSerializer::toHeaderValue($user_agent);
        }
        // header params
        if ($customer_ip !== null) {
            $headerParams['Customer-Ip'] = ObjectSerializer::toHeaderValue($customer_ip);
        }
        // header params
        if ($customer_session_id !== null) {
            $headerParams['Customer-Session-Id'] = ObjectSerializer::toHeaderValue($customer_session_id);
        }
        // header params
        if ($test !== null) {
            $headerParams['Test'] = ObjectSerializer::toHeaderValue($test);
        }



        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getCalendarAvailability
     *
     * Get a calendar of availability dates for properties. This is currently a Vrbo property only feature.
     *
     * @param  string $accept Specifies the response format that the client would like to receive back. This must be &#x60;application/json&#x60;. (required)
     * @param  string $accept_encoding Specifies the response encoding that the client would like to receive back. This must be &#x60;gzip&#x60;. (required)
     * @param  string $authorization The custom generated authentication header. Refer to our [signature authentication](https://developer.expediapartnersolutions.com/reference/signature-authentication) page for full details. (required)
     * @param  string $user_agent The &#x60;User-Agent&#x60; header string from the customer&#39;s request, as captured by your integration. If you are building an application then the &#x60;User-Agent&#x60; value should be &#x60;{app name}/{app version}&#x60;. (required)
     * @param  string[] $property_id The ID of the property you want to search for. You can provide 1 to 250 property_id parameters. (required)
     * @param  \DateTime $start_date The first day of availability information to be returned, in ISO 8601 format (YYYY-MM-DD), up to 500 days in the future from the current date. (required)
     * @param  \DateTime $end_date The last day of availability information to be returned, in ISO 8601 format (YYYY-MM-DD). This must be 365 days or less from the start_date. (required)
     * @param  string $test Shop calls have a test header that can be used to return set responses with the following keywords:&lt;br&gt; * &#x60;standard&#x60; * &#x60;service_unavailable&#x60; * &#x60;unknown_internal_error&#x60; (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getCalendarAvailability'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\PropertyCalendarAvailability[]|\OpenAPI\Client\Model\Error|\OpenAPI\Client\Model\Error|\OpenAPI\Client\Model\Error|\OpenAPI\Client\Model\Error|\OpenAPI\Client\Model\Error|\OpenAPI\Client\Model\Error|\OpenAPI\Client\Model\Error
     */
    public function getCalendarAvailability($accept, $accept_encoding, $authorization, $user_agent, $property_id, $start_date, $end_date, $test = null, string $contentType = self::contentTypes['getCalendarAvailability'][0])
    {
        list($response) = $this->getCalendarAvailabilityWithHttpInfo($accept, $accept_encoding, $authorization, $user_agent, $property_id, $start_date, $end_date, $test, $contentType);
        return $response;
    }

    /**
     * Operation getCalendarAvailabilityWithHttpInfo
     *
     * Get a calendar of availability dates for properties. This is currently a Vrbo property only feature.
     *
     * @param  string $accept Specifies the response format that the client would like to receive back. This must be &#x60;application/json&#x60;. (required)
     * @param  string $accept_encoding Specifies the response encoding that the client would like to receive back. This must be &#x60;gzip&#x60;. (required)
     * @param  string $authorization The custom generated authentication header. Refer to our [signature authentication](https://developer.expediapartnersolutions.com/reference/signature-authentication) page for full details. (required)
     * @param  string $user_agent The &#x60;User-Agent&#x60; header string from the customer&#39;s request, as captured by your integration. If you are building an application then the &#x60;User-Agent&#x60; value should be &#x60;{app name}/{app version}&#x60;. (required)
     * @param  string[] $property_id The ID of the property you want to search for. You can provide 1 to 250 property_id parameters. (required)
     * @param  \DateTime $start_date The first day of availability information to be returned, in ISO 8601 format (YYYY-MM-DD), up to 500 days in the future from the current date. (required)
     * @param  \DateTime $end_date The last day of availability information to be returned, in ISO 8601 format (YYYY-MM-DD). This must be 365 days or less from the start_date. (required)
     * @param  string $test Shop calls have a test header that can be used to return set responses with the following keywords:&lt;br&gt; * &#x60;standard&#x60; * &#x60;service_unavailable&#x60; * &#x60;unknown_internal_error&#x60; (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getCalendarAvailability'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\PropertyCalendarAvailability[]|\OpenAPI\Client\Model\Error|\OpenAPI\Client\Model\Error|\OpenAPI\Client\Model\Error|\OpenAPI\Client\Model\Error|\OpenAPI\Client\Model\Error|\OpenAPI\Client\Model\Error|\OpenAPI\Client\Model\Error, HTTP status code, HTTP response headers (array of strings)
     */
    public function getCalendarAvailabilityWithHttpInfo($accept, $accept_encoding, $authorization, $user_agent, $property_id, $start_date, $end_date, $test = null, string $contentType = self::contentTypes['getCalendarAvailability'][0])
    {
        $request = $this->getCalendarAvailabilityRequest($accept, $accept_encoding, $authorization, $user_agent, $property_id, $start_date, $end_date, $test, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\PropertyCalendarAvailability[]' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\PropertyCalendarAvailability[]' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\PropertyCalendarAvailability[]', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 400:
                    if ('\OpenAPI\Client\Model\Error' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\Error' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\Error', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 401:
                    if ('\OpenAPI\Client\Model\Error' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\Error' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\Error', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 403:
                    if ('\OpenAPI\Client\Model\Error' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\Error' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\Error', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 426:
                    if ('\OpenAPI\Client\Model\Error' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\Error' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\Error', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 429:
                    if ('\OpenAPI\Client\Model\Error' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\Error' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\Error', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 500:
                    if ('\OpenAPI\Client\Model\Error' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\Error' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\Error', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 503:
                    if ('\OpenAPI\Client\Model\Error' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\Error' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\Error', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\PropertyCalendarAvailability[]';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\PropertyCalendarAvailability[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\Error',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 401:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\Error',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 403:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\Error',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 426:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\Error',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 429:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\Error',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 500:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\Error',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 503:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\Error',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getCalendarAvailabilityAsync
     *
     * Get a calendar of availability dates for properties. This is currently a Vrbo property only feature.
     *
     * @param  string $accept Specifies the response format that the client would like to receive back. This must be &#x60;application/json&#x60;. (required)
     * @param  string $accept_encoding Specifies the response encoding that the client would like to receive back. This must be &#x60;gzip&#x60;. (required)
     * @param  string $authorization The custom generated authentication header. Refer to our [signature authentication](https://developer.expediapartnersolutions.com/reference/signature-authentication) page for full details. (required)
     * @param  string $user_agent The &#x60;User-Agent&#x60; header string from the customer&#39;s request, as captured by your integration. If you are building an application then the &#x60;User-Agent&#x60; value should be &#x60;{app name}/{app version}&#x60;. (required)
     * @param  string[] $property_id The ID of the property you want to search for. You can provide 1 to 250 property_id parameters. (required)
     * @param  \DateTime $start_date The first day of availability information to be returned, in ISO 8601 format (YYYY-MM-DD), up to 500 days in the future from the current date. (required)
     * @param  \DateTime $end_date The last day of availability information to be returned, in ISO 8601 format (YYYY-MM-DD). This must be 365 days or less from the start_date. (required)
     * @param  string $test Shop calls have a test header that can be used to return set responses with the following keywords:&lt;br&gt; * &#x60;standard&#x60; * &#x60;service_unavailable&#x60; * &#x60;unknown_internal_error&#x60; (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getCalendarAvailability'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getCalendarAvailabilityAsync($accept, $accept_encoding, $authorization, $user_agent, $property_id, $start_date, $end_date, $test = null, string $contentType = self::contentTypes['getCalendarAvailability'][0])
    {
        return $this->getCalendarAvailabilityAsyncWithHttpInfo($accept, $accept_encoding, $authorization, $user_agent, $property_id, $start_date, $end_date, $test, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getCalendarAvailabilityAsyncWithHttpInfo
     *
     * Get a calendar of availability dates for properties. This is currently a Vrbo property only feature.
     *
     * @param  string $accept Specifies the response format that the client would like to receive back. This must be &#x60;application/json&#x60;. (required)
     * @param  string $accept_encoding Specifies the response encoding that the client would like to receive back. This must be &#x60;gzip&#x60;. (required)
     * @param  string $authorization The custom generated authentication header. Refer to our [signature authentication](https://developer.expediapartnersolutions.com/reference/signature-authentication) page for full details. (required)
     * @param  string $user_agent The &#x60;User-Agent&#x60; header string from the customer&#39;s request, as captured by your integration. If you are building an application then the &#x60;User-Agent&#x60; value should be &#x60;{app name}/{app version}&#x60;. (required)
     * @param  string[] $property_id The ID of the property you want to search for. You can provide 1 to 250 property_id parameters. (required)
     * @param  \DateTime $start_date The first day of availability information to be returned, in ISO 8601 format (YYYY-MM-DD), up to 500 days in the future from the current date. (required)
     * @param  \DateTime $end_date The last day of availability information to be returned, in ISO 8601 format (YYYY-MM-DD). This must be 365 days or less from the start_date. (required)
     * @param  string $test Shop calls have a test header that can be used to return set responses with the following keywords:&lt;br&gt; * &#x60;standard&#x60; * &#x60;service_unavailable&#x60; * &#x60;unknown_internal_error&#x60; (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getCalendarAvailability'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getCalendarAvailabilityAsyncWithHttpInfo($accept, $accept_encoding, $authorization, $user_agent, $property_id, $start_date, $end_date, $test = null, string $contentType = self::contentTypes['getCalendarAvailability'][0])
    {
        $returnType = '\OpenAPI\Client\Model\PropertyCalendarAvailability[]';
        $request = $this->getCalendarAvailabilityRequest($accept, $accept_encoding, $authorization, $user_agent, $property_id, $start_date, $end_date, $test, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getCalendarAvailability'
     *
     * @param  string $accept Specifies the response format that the client would like to receive back. This must be &#x60;application/json&#x60;. (required)
     * @param  string $accept_encoding Specifies the response encoding that the client would like to receive back. This must be &#x60;gzip&#x60;. (required)
     * @param  string $authorization The custom generated authentication header. Refer to our [signature authentication](https://developer.expediapartnersolutions.com/reference/signature-authentication) page for full details. (required)
     * @param  string $user_agent The &#x60;User-Agent&#x60; header string from the customer&#39;s request, as captured by your integration. If you are building an application then the &#x60;User-Agent&#x60; value should be &#x60;{app name}/{app version}&#x60;. (required)
     * @param  string[] $property_id The ID of the property you want to search for. You can provide 1 to 250 property_id parameters. (required)
     * @param  \DateTime $start_date The first day of availability information to be returned, in ISO 8601 format (YYYY-MM-DD), up to 500 days in the future from the current date. (required)
     * @param  \DateTime $end_date The last day of availability information to be returned, in ISO 8601 format (YYYY-MM-DD). This must be 365 days or less from the start_date. (required)
     * @param  string $test Shop calls have a test header that can be used to return set responses with the following keywords:&lt;br&gt; * &#x60;standard&#x60; * &#x60;service_unavailable&#x60; * &#x60;unknown_internal_error&#x60; (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getCalendarAvailability'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function getCalendarAvailabilityRequest($accept, $accept_encoding, $authorization, $user_agent, $property_id, $start_date, $end_date, $test = null, string $contentType = self::contentTypes['getCalendarAvailability'][0])
    {

        // verify the required parameter 'accept' is set
        if ($accept === null || (is_array($accept) && count($accept) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $accept when calling getCalendarAvailability'
            );
        }

        // verify the required parameter 'accept_encoding' is set
        if ($accept_encoding === null || (is_array($accept_encoding) && count($accept_encoding) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $accept_encoding when calling getCalendarAvailability'
            );
        }

        // verify the required parameter 'authorization' is set
        if ($authorization === null || (is_array($authorization) && count($authorization) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $authorization when calling getCalendarAvailability'
            );
        }

        // verify the required parameter 'user_agent' is set
        if ($user_agent === null || (is_array($user_agent) && count($user_agent) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $user_agent when calling getCalendarAvailability'
            );
        }

        // verify the required parameter 'property_id' is set
        if ($property_id === null || (is_array($property_id) && count($property_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $property_id when calling getCalendarAvailability'
            );
        }

        // verify the required parameter 'start_date' is set
        if ($start_date === null || (is_array($start_date) && count($start_date) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $start_date when calling getCalendarAvailability'
            );
        }

        // verify the required parameter 'end_date' is set
        if ($end_date === null || (is_array($end_date) && count($end_date) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $end_date when calling getCalendarAvailability'
            );
        }



        $resourcePath = '/calendars/availability';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $property_id,
            'property_id', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            true // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $start_date,
            'start_date', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            true // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $end_date,
            'end_date', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            true // required
        ) ?? []);

        // header params
        if ($accept !== null) {
            $headerParams['Accept'] = ObjectSerializer::toHeaderValue($accept);
        }
        // header params
        if ($accept_encoding !== null) {
            $headerParams['Accept-Encoding'] = ObjectSerializer::toHeaderValue($accept_encoding);
        }
        // header params
        if ($authorization !== null) {
            $headerParams['Authorization'] = ObjectSerializer::toHeaderValue($authorization);
        }
        // header params
        if ($user_agent !== null) {
            $headerParams['User-Agent'] = ObjectSerializer::toHeaderValue($user_agent);
        }
        // header params
        if ($test !== null) {
            $headerParams['Test'] = ObjectSerializer::toHeaderValue($test);
        }



        $headers = $this->headerSelector->selectHeaders(
            ['application/json', 'Example', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getPaymentOptions
     *
     * Get Accepted Payment Types - EPS MOR Only
     *
     * @param  string $accept Specifies the response format that the client would like to receive back. This must be &#x60;application/json&#x60;. (required)
     * @param  string $accept_encoding Specifies the response encoding that the client would like to receive back. This must be &#x60;gzip&#x60;. (required)
     * @param  string $property_id Expedia Property ID.&lt;br&gt; (required)
     * @param  string $token Provided as part of the link object and used to maintain state across calls. This simplifies each subsequent call by limiting the amount of information required at each step and reduces the potential for errors. Token values cannot be viewed or changed. (required)
     * @param  string $user_agent The &#x60;User-Agent&#x60; header string from the customer&#39;s request, as captured by your integration. If you are building an application then the &#x60;User-Agent&#x60; value should be &#x60;{app name}/{app version}&#x60;. (required)
     * @param  string $customer_ip IP address of the customer, as captured by your integration.&lt;br&gt; Ensure your integration passes the customer&#39;s IP, not your own. This value helps determine their location and assign the correct payment gateway.&lt;br&gt; Also used for fraud recovery and other important analytics. (optional)
     * @param  string $customer_session_id Insert your own unique value for each user session, beginning with the first API call. Continue to pass the same value for each subsequent API call during the user&#39;s session, using a new value for every new customer session.&lt;br&gt; Including this value greatly eases EPS&#39;s internal debugging process for issues with partner requests, as it explicitly links together request paths for individual user&#39;s session. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getPaymentOptions'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\PaymentOption|\OpenAPI\Client\Model\Error|\OpenAPI\Client\Model\Error|\OpenAPI\Client\Model\Error|\OpenAPI\Client\Model\Error|\OpenAPI\Client\Model\Error
     */
    public function getPaymentOptions($accept, $accept_encoding, $property_id, $token, $user_agent, $customer_ip = null, $customer_session_id = null, string $contentType = self::contentTypes['getPaymentOptions'][0])
    {
        list($response) = $this->getPaymentOptionsWithHttpInfo($accept, $accept_encoding, $property_id, $token, $user_agent, $customer_ip, $customer_session_id, $contentType);
        return $response;
    }

    /**
     * Operation getPaymentOptionsWithHttpInfo
     *
     * Get Accepted Payment Types - EPS MOR Only
     *
     * @param  string $accept Specifies the response format that the client would like to receive back. This must be &#x60;application/json&#x60;. (required)
     * @param  string $accept_encoding Specifies the response encoding that the client would like to receive back. This must be &#x60;gzip&#x60;. (required)
     * @param  string $property_id Expedia Property ID.&lt;br&gt; (required)
     * @param  string $token Provided as part of the link object and used to maintain state across calls. This simplifies each subsequent call by limiting the amount of information required at each step and reduces the potential for errors. Token values cannot be viewed or changed. (required)
     * @param  string $user_agent The &#x60;User-Agent&#x60; header string from the customer&#39;s request, as captured by your integration. If you are building an application then the &#x60;User-Agent&#x60; value should be &#x60;{app name}/{app version}&#x60;. (required)
     * @param  string $customer_ip IP address of the customer, as captured by your integration.&lt;br&gt; Ensure your integration passes the customer&#39;s IP, not your own. This value helps determine their location and assign the correct payment gateway.&lt;br&gt; Also used for fraud recovery and other important analytics. (optional)
     * @param  string $customer_session_id Insert your own unique value for each user session, beginning with the first API call. Continue to pass the same value for each subsequent API call during the user&#39;s session, using a new value for every new customer session.&lt;br&gt; Including this value greatly eases EPS&#39;s internal debugging process for issues with partner requests, as it explicitly links together request paths for individual user&#39;s session. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getPaymentOptions'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\PaymentOption|\OpenAPI\Client\Model\Error|\OpenAPI\Client\Model\Error|\OpenAPI\Client\Model\Error|\OpenAPI\Client\Model\Error|\OpenAPI\Client\Model\Error, HTTP status code, HTTP response headers (array of strings)
     */
    public function getPaymentOptionsWithHttpInfo($accept, $accept_encoding, $property_id, $token, $user_agent, $customer_ip = null, $customer_session_id = null, string $contentType = self::contentTypes['getPaymentOptions'][0])
    {
        $request = $this->getPaymentOptionsRequest($accept, $accept_encoding, $property_id, $token, $user_agent, $customer_ip, $customer_session_id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\PaymentOption' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\PaymentOption' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\PaymentOption', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 400:
                    if ('\OpenAPI\Client\Model\Error' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\Error' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\Error', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 426:
                    if ('\OpenAPI\Client\Model\Error' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\Error' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\Error', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 429:
                    if ('\OpenAPI\Client\Model\Error' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\Error' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\Error', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 500:
                    if ('\OpenAPI\Client\Model\Error' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\Error' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\Error', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 503:
                    if ('\OpenAPI\Client\Model\Error' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\Error' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\Error', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\PaymentOption';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\PaymentOption',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\Error',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 426:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\Error',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 429:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\Error',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 500:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\Error',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 503:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\Error',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getPaymentOptionsAsync
     *
     * Get Accepted Payment Types - EPS MOR Only
     *
     * @param  string $accept Specifies the response format that the client would like to receive back. This must be &#x60;application/json&#x60;. (required)
     * @param  string $accept_encoding Specifies the response encoding that the client would like to receive back. This must be &#x60;gzip&#x60;. (required)
     * @param  string $property_id Expedia Property ID.&lt;br&gt; (required)
     * @param  string $token Provided as part of the link object and used to maintain state across calls. This simplifies each subsequent call by limiting the amount of information required at each step and reduces the potential for errors. Token values cannot be viewed or changed. (required)
     * @param  string $user_agent The &#x60;User-Agent&#x60; header string from the customer&#39;s request, as captured by your integration. If you are building an application then the &#x60;User-Agent&#x60; value should be &#x60;{app name}/{app version}&#x60;. (required)
     * @param  string $customer_ip IP address of the customer, as captured by your integration.&lt;br&gt; Ensure your integration passes the customer&#39;s IP, not your own. This value helps determine their location and assign the correct payment gateway.&lt;br&gt; Also used for fraud recovery and other important analytics. (optional)
     * @param  string $customer_session_id Insert your own unique value for each user session, beginning with the first API call. Continue to pass the same value for each subsequent API call during the user&#39;s session, using a new value for every new customer session.&lt;br&gt; Including this value greatly eases EPS&#39;s internal debugging process for issues with partner requests, as it explicitly links together request paths for individual user&#39;s session. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getPaymentOptions'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getPaymentOptionsAsync($accept, $accept_encoding, $property_id, $token, $user_agent, $customer_ip = null, $customer_session_id = null, string $contentType = self::contentTypes['getPaymentOptions'][0])
    {
        return $this->getPaymentOptionsAsyncWithHttpInfo($accept, $accept_encoding, $property_id, $token, $user_agent, $customer_ip, $customer_session_id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getPaymentOptionsAsyncWithHttpInfo
     *
     * Get Accepted Payment Types - EPS MOR Only
     *
     * @param  string $accept Specifies the response format that the client would like to receive back. This must be &#x60;application/json&#x60;. (required)
     * @param  string $accept_encoding Specifies the response encoding that the client would like to receive back. This must be &#x60;gzip&#x60;. (required)
     * @param  string $property_id Expedia Property ID.&lt;br&gt; (required)
     * @param  string $token Provided as part of the link object and used to maintain state across calls. This simplifies each subsequent call by limiting the amount of information required at each step and reduces the potential for errors. Token values cannot be viewed or changed. (required)
     * @param  string $user_agent The &#x60;User-Agent&#x60; header string from the customer&#39;s request, as captured by your integration. If you are building an application then the &#x60;User-Agent&#x60; value should be &#x60;{app name}/{app version}&#x60;. (required)
     * @param  string $customer_ip IP address of the customer, as captured by your integration.&lt;br&gt; Ensure your integration passes the customer&#39;s IP, not your own. This value helps determine their location and assign the correct payment gateway.&lt;br&gt; Also used for fraud recovery and other important analytics. (optional)
     * @param  string $customer_session_id Insert your own unique value for each user session, beginning with the first API call. Continue to pass the same value for each subsequent API call during the user&#39;s session, using a new value for every new customer session.&lt;br&gt; Including this value greatly eases EPS&#39;s internal debugging process for issues with partner requests, as it explicitly links together request paths for individual user&#39;s session. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getPaymentOptions'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getPaymentOptionsAsyncWithHttpInfo($accept, $accept_encoding, $property_id, $token, $user_agent, $customer_ip = null, $customer_session_id = null, string $contentType = self::contentTypes['getPaymentOptions'][0])
    {
        $returnType = '\OpenAPI\Client\Model\PaymentOption';
        $request = $this->getPaymentOptionsRequest($accept, $accept_encoding, $property_id, $token, $user_agent, $customer_ip, $customer_session_id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getPaymentOptions'
     *
     * @param  string $accept Specifies the response format that the client would like to receive back. This must be &#x60;application/json&#x60;. (required)
     * @param  string $accept_encoding Specifies the response encoding that the client would like to receive back. This must be &#x60;gzip&#x60;. (required)
     * @param  string $property_id Expedia Property ID.&lt;br&gt; (required)
     * @param  string $token Provided as part of the link object and used to maintain state across calls. This simplifies each subsequent call by limiting the amount of information required at each step and reduces the potential for errors. Token values cannot be viewed or changed. (required)
     * @param  string $user_agent The &#x60;User-Agent&#x60; header string from the customer&#39;s request, as captured by your integration. If you are building an application then the &#x60;User-Agent&#x60; value should be &#x60;{app name}/{app version}&#x60;. (required)
     * @param  string $customer_ip IP address of the customer, as captured by your integration.&lt;br&gt; Ensure your integration passes the customer&#39;s IP, not your own. This value helps determine their location and assign the correct payment gateway.&lt;br&gt; Also used for fraud recovery and other important analytics. (optional)
     * @param  string $customer_session_id Insert your own unique value for each user session, beginning with the first API call. Continue to pass the same value for each subsequent API call during the user&#39;s session, using a new value for every new customer session.&lt;br&gt; Including this value greatly eases EPS&#39;s internal debugging process for issues with partner requests, as it explicitly links together request paths for individual user&#39;s session. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getPaymentOptions'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function getPaymentOptionsRequest($accept, $accept_encoding, $property_id, $token, $user_agent, $customer_ip = null, $customer_session_id = null, string $contentType = self::contentTypes['getPaymentOptions'][0])
    {

        // verify the required parameter 'accept' is set
        if ($accept === null || (is_array($accept) && count($accept) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $accept when calling getPaymentOptions'
            );
        }

        // verify the required parameter 'accept_encoding' is set
        if ($accept_encoding === null || (is_array($accept_encoding) && count($accept_encoding) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $accept_encoding when calling getPaymentOptions'
            );
        }

        // verify the required parameter 'property_id' is set
        if ($property_id === null || (is_array($property_id) && count($property_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $property_id when calling getPaymentOptions'
            );
        }

        // verify the required parameter 'token' is set
        if ($token === null || (is_array($token) && count($token) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $token when calling getPaymentOptions'
            );
        }

        // verify the required parameter 'user_agent' is set
        if ($user_agent === null || (is_array($user_agent) && count($user_agent) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $user_agent when calling getPaymentOptions'
            );
        }




        $resourcePath = '/properties/{property_id}/payment-options';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $token,
            'token', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            true // required
        ) ?? []);

        // header params
        if ($accept !== null) {
            $headerParams['Accept'] = ObjectSerializer::toHeaderValue($accept);
        }
        // header params
        if ($accept_encoding !== null) {
            $headerParams['Accept-Encoding'] = ObjectSerializer::toHeaderValue($accept_encoding);
        }
        // header params
        if ($customer_ip !== null) {
            $headerParams['Customer-Ip'] = ObjectSerializer::toHeaderValue($customer_ip);
        }
        // header params
        if ($customer_session_id !== null) {
            $headerParams['Customer-Session-Id'] = ObjectSerializer::toHeaderValue($customer_session_id);
        }
        // header params
        if ($user_agent !== null) {
            $headerParams['User-Agent'] = ObjectSerializer::toHeaderValue($user_agent);
        }

        // path params
        if ($property_id !== null) {
            $resourcePath = str_replace(
                '{' . 'property_id' . '}',
                ObjectSerializer::toPathValue($property_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation priceCheck
     *
     * Price-Check
     *
     * @param  string $accept Specifies the response format that the client would like to receive back. This must be &#x60;application/json&#x60;. (required)
     * @param  string $accept_encoding Specifies the response encoding that the client would like to receive back. This must be &#x60;gzip&#x60;. (required)
     * @param  string $user_agent The &#x60;User-Agent&#x60; header string from the customer&#39;s request, as captured by your integration. If you are building an application then the &#x60;User-Agent&#x60; value should be &#x60;{app name}/{app version}&#x60;. (required)
     * @param  string $property_id Expedia Property ID.&lt;br&gt; (required)
     * @param  string $room_id Room ID of a property.&lt;br&gt; (required)
     * @param  string $rate_id Rate ID of a room.&lt;br&gt; (required)
     * @param  string $token A hashed collection of query parameters. Used to maintain state across calls. This token is provided as part of the price check link from the shop response. (required)
     * @param  string $customer_ip IP address of the customer, as captured by your integration.&lt;br&gt; Ensure your integration passes the customer&#39;s IP, not your own. This value helps determine their location and assign the correct payment gateway.&lt;br&gt; Also used for fraud recovery and other important analytics. (optional)
     * @param  string $customer_session_id Insert your own unique value for each user session, beginning with the first API call. Continue to pass the same value for each subsequent API call during the user&#39;s session, using a new value for every new customer session.&lt;br&gt; Including this value greatly eases EPS&#39;s internal debugging process for issues with partner requests, as it explicitly links together request paths for individual user&#39;s session. (optional)
     * @param  string $test Price check calls have a test header that can be used to return set responses with the following keywords:   * &#x60;available&#x60;   * &#x60;price_changed&#x60;   * &#x60;sold_out&#x60;   * &#x60;service_unavailable&#x60;   * &#x60;unknown_internal_error&#x60; (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['priceCheck'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\RoomPriceCheck|\OpenAPI\Client\Model\Error|\OpenAPI\Client\Model\Error|\OpenAPI\Client\Model\Error|\OpenAPI\Client\Model\Error|\OpenAPI\Client\Model\Error|\OpenAPI\Client\Model\Error|\OpenAPI\Client\Model\Error
     */
    public function priceCheck($accept, $accept_encoding, $user_agent, $property_id, $room_id, $rate_id, $token, $customer_ip = null, $customer_session_id = null, $test = null, string $contentType = self::contentTypes['priceCheck'][0])
    {
        list($response) = $this->priceCheckWithHttpInfo($accept, $accept_encoding, $user_agent, $property_id, $room_id, $rate_id, $token, $customer_ip, $customer_session_id, $test, $contentType);
        return $response;
    }

    /**
     * Operation priceCheckWithHttpInfo
     *
     * Price-Check
     *
     * @param  string $accept Specifies the response format that the client would like to receive back. This must be &#x60;application/json&#x60;. (required)
     * @param  string $accept_encoding Specifies the response encoding that the client would like to receive back. This must be &#x60;gzip&#x60;. (required)
     * @param  string $user_agent The &#x60;User-Agent&#x60; header string from the customer&#39;s request, as captured by your integration. If you are building an application then the &#x60;User-Agent&#x60; value should be &#x60;{app name}/{app version}&#x60;. (required)
     * @param  string $property_id Expedia Property ID.&lt;br&gt; (required)
     * @param  string $room_id Room ID of a property.&lt;br&gt; (required)
     * @param  string $rate_id Rate ID of a room.&lt;br&gt; (required)
     * @param  string $token A hashed collection of query parameters. Used to maintain state across calls. This token is provided as part of the price check link from the shop response. (required)
     * @param  string $customer_ip IP address of the customer, as captured by your integration.&lt;br&gt; Ensure your integration passes the customer&#39;s IP, not your own. This value helps determine their location and assign the correct payment gateway.&lt;br&gt; Also used for fraud recovery and other important analytics. (optional)
     * @param  string $customer_session_id Insert your own unique value for each user session, beginning with the first API call. Continue to pass the same value for each subsequent API call during the user&#39;s session, using a new value for every new customer session.&lt;br&gt; Including this value greatly eases EPS&#39;s internal debugging process for issues with partner requests, as it explicitly links together request paths for individual user&#39;s session. (optional)
     * @param  string $test Price check calls have a test header that can be used to return set responses with the following keywords:   * &#x60;available&#x60;   * &#x60;price_changed&#x60;   * &#x60;sold_out&#x60;   * &#x60;service_unavailable&#x60;   * &#x60;unknown_internal_error&#x60; (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['priceCheck'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\RoomPriceCheck|\OpenAPI\Client\Model\Error|\OpenAPI\Client\Model\Error|\OpenAPI\Client\Model\Error|\OpenAPI\Client\Model\Error|\OpenAPI\Client\Model\Error|\OpenAPI\Client\Model\Error|\OpenAPI\Client\Model\Error, HTTP status code, HTTP response headers (array of strings)
     */
    public function priceCheckWithHttpInfo($accept, $accept_encoding, $user_agent, $property_id, $room_id, $rate_id, $token, $customer_ip = null, $customer_session_id = null, $test = null, string $contentType = self::contentTypes['priceCheck'][0])
    {
        $request = $this->priceCheckRequest($accept, $accept_encoding, $user_agent, $property_id, $room_id, $rate_id, $token, $customer_ip, $customer_session_id, $test, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\RoomPriceCheck' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\RoomPriceCheck' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\RoomPriceCheck', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 400:
                    if ('\OpenAPI\Client\Model\Error' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\Error' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\Error', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 401:
                    if ('\OpenAPI\Client\Model\Error' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\Error' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\Error', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 403:
                    if ('\OpenAPI\Client\Model\Error' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\Error' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\Error', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 426:
                    if ('\OpenAPI\Client\Model\Error' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\Error' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\Error', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 429:
                    if ('\OpenAPI\Client\Model\Error' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\Error' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\Error', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 500:
                    if ('\OpenAPI\Client\Model\Error' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\Error' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\Error', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 503:
                    if ('\OpenAPI\Client\Model\Error' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\Error' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\Error', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\RoomPriceCheck';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\RoomPriceCheck',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\Error',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 401:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\Error',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 403:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\Error',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 426:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\Error',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 429:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\Error',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 500:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\Error',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 503:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\Error',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation priceCheckAsync
     *
     * Price-Check
     *
     * @param  string $accept Specifies the response format that the client would like to receive back. This must be &#x60;application/json&#x60;. (required)
     * @param  string $accept_encoding Specifies the response encoding that the client would like to receive back. This must be &#x60;gzip&#x60;. (required)
     * @param  string $user_agent The &#x60;User-Agent&#x60; header string from the customer&#39;s request, as captured by your integration. If you are building an application then the &#x60;User-Agent&#x60; value should be &#x60;{app name}/{app version}&#x60;. (required)
     * @param  string $property_id Expedia Property ID.&lt;br&gt; (required)
     * @param  string $room_id Room ID of a property.&lt;br&gt; (required)
     * @param  string $rate_id Rate ID of a room.&lt;br&gt; (required)
     * @param  string $token A hashed collection of query parameters. Used to maintain state across calls. This token is provided as part of the price check link from the shop response. (required)
     * @param  string $customer_ip IP address of the customer, as captured by your integration.&lt;br&gt; Ensure your integration passes the customer&#39;s IP, not your own. This value helps determine their location and assign the correct payment gateway.&lt;br&gt; Also used for fraud recovery and other important analytics. (optional)
     * @param  string $customer_session_id Insert your own unique value for each user session, beginning with the first API call. Continue to pass the same value for each subsequent API call during the user&#39;s session, using a new value for every new customer session.&lt;br&gt; Including this value greatly eases EPS&#39;s internal debugging process for issues with partner requests, as it explicitly links together request paths for individual user&#39;s session. (optional)
     * @param  string $test Price check calls have a test header that can be used to return set responses with the following keywords:   * &#x60;available&#x60;   * &#x60;price_changed&#x60;   * &#x60;sold_out&#x60;   * &#x60;service_unavailable&#x60;   * &#x60;unknown_internal_error&#x60; (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['priceCheck'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function priceCheckAsync($accept, $accept_encoding, $user_agent, $property_id, $room_id, $rate_id, $token, $customer_ip = null, $customer_session_id = null, $test = null, string $contentType = self::contentTypes['priceCheck'][0])
    {
        return $this->priceCheckAsyncWithHttpInfo($accept, $accept_encoding, $user_agent, $property_id, $room_id, $rate_id, $token, $customer_ip, $customer_session_id, $test, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation priceCheckAsyncWithHttpInfo
     *
     * Price-Check
     *
     * @param  string $accept Specifies the response format that the client would like to receive back. This must be &#x60;application/json&#x60;. (required)
     * @param  string $accept_encoding Specifies the response encoding that the client would like to receive back. This must be &#x60;gzip&#x60;. (required)
     * @param  string $user_agent The &#x60;User-Agent&#x60; header string from the customer&#39;s request, as captured by your integration. If you are building an application then the &#x60;User-Agent&#x60; value should be &#x60;{app name}/{app version}&#x60;. (required)
     * @param  string $property_id Expedia Property ID.&lt;br&gt; (required)
     * @param  string $room_id Room ID of a property.&lt;br&gt; (required)
     * @param  string $rate_id Rate ID of a room.&lt;br&gt; (required)
     * @param  string $token A hashed collection of query parameters. Used to maintain state across calls. This token is provided as part of the price check link from the shop response. (required)
     * @param  string $customer_ip IP address of the customer, as captured by your integration.&lt;br&gt; Ensure your integration passes the customer&#39;s IP, not your own. This value helps determine their location and assign the correct payment gateway.&lt;br&gt; Also used for fraud recovery and other important analytics. (optional)
     * @param  string $customer_session_id Insert your own unique value for each user session, beginning with the first API call. Continue to pass the same value for each subsequent API call during the user&#39;s session, using a new value for every new customer session.&lt;br&gt; Including this value greatly eases EPS&#39;s internal debugging process for issues with partner requests, as it explicitly links together request paths for individual user&#39;s session. (optional)
     * @param  string $test Price check calls have a test header that can be used to return set responses with the following keywords:   * &#x60;available&#x60;   * &#x60;price_changed&#x60;   * &#x60;sold_out&#x60;   * &#x60;service_unavailable&#x60;   * &#x60;unknown_internal_error&#x60; (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['priceCheck'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function priceCheckAsyncWithHttpInfo($accept, $accept_encoding, $user_agent, $property_id, $room_id, $rate_id, $token, $customer_ip = null, $customer_session_id = null, $test = null, string $contentType = self::contentTypes['priceCheck'][0])
    {
        $returnType = '\OpenAPI\Client\Model\RoomPriceCheck';
        $request = $this->priceCheckRequest($accept, $accept_encoding, $user_agent, $property_id, $room_id, $rate_id, $token, $customer_ip, $customer_session_id, $test, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'priceCheck'
     *
     * @param  string $accept Specifies the response format that the client would like to receive back. This must be &#x60;application/json&#x60;. (required)
     * @param  string $accept_encoding Specifies the response encoding that the client would like to receive back. This must be &#x60;gzip&#x60;. (required)
     * @param  string $user_agent The &#x60;User-Agent&#x60; header string from the customer&#39;s request, as captured by your integration. If you are building an application then the &#x60;User-Agent&#x60; value should be &#x60;{app name}/{app version}&#x60;. (required)
     * @param  string $property_id Expedia Property ID.&lt;br&gt; (required)
     * @param  string $room_id Room ID of a property.&lt;br&gt; (required)
     * @param  string $rate_id Rate ID of a room.&lt;br&gt; (required)
     * @param  string $token A hashed collection of query parameters. Used to maintain state across calls. This token is provided as part of the price check link from the shop response. (required)
     * @param  string $customer_ip IP address of the customer, as captured by your integration.&lt;br&gt; Ensure your integration passes the customer&#39;s IP, not your own. This value helps determine their location and assign the correct payment gateway.&lt;br&gt; Also used for fraud recovery and other important analytics. (optional)
     * @param  string $customer_session_id Insert your own unique value for each user session, beginning with the first API call. Continue to pass the same value for each subsequent API call during the user&#39;s session, using a new value for every new customer session.&lt;br&gt; Including this value greatly eases EPS&#39;s internal debugging process for issues with partner requests, as it explicitly links together request paths for individual user&#39;s session. (optional)
     * @param  string $test Price check calls have a test header that can be used to return set responses with the following keywords:   * &#x60;available&#x60;   * &#x60;price_changed&#x60;   * &#x60;sold_out&#x60;   * &#x60;service_unavailable&#x60;   * &#x60;unknown_internal_error&#x60; (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['priceCheck'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function priceCheckRequest($accept, $accept_encoding, $user_agent, $property_id, $room_id, $rate_id, $token, $customer_ip = null, $customer_session_id = null, $test = null, string $contentType = self::contentTypes['priceCheck'][0])
    {

        // verify the required parameter 'accept' is set
        if ($accept === null || (is_array($accept) && count($accept) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $accept when calling priceCheck'
            );
        }

        // verify the required parameter 'accept_encoding' is set
        if ($accept_encoding === null || (is_array($accept_encoding) && count($accept_encoding) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $accept_encoding when calling priceCheck'
            );
        }

        // verify the required parameter 'user_agent' is set
        if ($user_agent === null || (is_array($user_agent) && count($user_agent) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $user_agent when calling priceCheck'
            );
        }

        // verify the required parameter 'property_id' is set
        if ($property_id === null || (is_array($property_id) && count($property_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $property_id when calling priceCheck'
            );
        }

        // verify the required parameter 'room_id' is set
        if ($room_id === null || (is_array($room_id) && count($room_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $room_id when calling priceCheck'
            );
        }

        // verify the required parameter 'rate_id' is set
        if ($rate_id === null || (is_array($rate_id) && count($rate_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $rate_id when calling priceCheck'
            );
        }

        // verify the required parameter 'token' is set
        if ($token === null || (is_array($token) && count($token) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $token when calling priceCheck'
            );
        }





        $resourcePath = '/properties/{property_id}/rooms/{room_id}/rates/{rate_id}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $token,
            'token', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            true // required
        ) ?? []);

        // header params
        if ($accept !== null) {
            $headerParams['Accept'] = ObjectSerializer::toHeaderValue($accept);
        }
        // header params
        if ($accept_encoding !== null) {
            $headerParams['Accept-Encoding'] = ObjectSerializer::toHeaderValue($accept_encoding);
        }
        // header params
        if ($customer_ip !== null) {
            $headerParams['Customer-Ip'] = ObjectSerializer::toHeaderValue($customer_ip);
        }
        // header params
        if ($customer_session_id !== null) {
            $headerParams['Customer-Session-Id'] = ObjectSerializer::toHeaderValue($customer_session_id);
        }
        // header params
        if ($user_agent !== null) {
            $headerParams['User-Agent'] = ObjectSerializer::toHeaderValue($user_agent);
        }
        // header params
        if ($test !== null) {
            $headerParams['Test'] = ObjectSerializer::toHeaderValue($test);
        }

        // path params
        if ($property_id !== null) {
            $resourcePath = str_replace(
                '{' . 'property_id' . '}',
                ObjectSerializer::toPathValue($property_id),
                $resourcePath
            );
        }
        // path params
        if ($room_id !== null) {
            $resourcePath = str_replace(
                '{' . 'room_id' . '}',
                ObjectSerializer::toPathValue($room_id),
                $resourcePath
            );
        }
        // path params
        if ($rate_id !== null) {
            $resourcePath = str_replace(
                '{' . 'rate_id' . '}',
                ObjectSerializer::toPathValue($rate_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Create http client option
     *
     * @throws \RuntimeException on file opening failure
     * @return array of http client options
     */
    protected function createHttpClientOption()
    {
        $options = [];
        if ($this->config->getDebug()) {
            $options[RequestOptions::DEBUG] = fopen($this->config->getDebugFile(), 'a');
            if (!$options[RequestOptions::DEBUG]) {
                throw new \RuntimeException('Failed to open the debug file: ' . $this->config->getDebugFile());
            }
        }

        return $options;
    }
}
